:: Floating-point Arithmetic
:: by Alexander M. Nelson
::
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ
 vocabularies NUMBERS, ORDINAL1, CARD_1, SUBSET_1, XBOOLE_0, ARYTM_2, ARYTM_3,
   ZFMISC_1, XCMPLX_0, XREAL_0, XXREAL_0, TARSKI, FUNCT_7, RELAT_1,
   REAL_1, INT_1, PREPOWER, POWER, ARYTM_1, NAT_1, COUNTERS,
   COMPLEX1, FINSET_1,
   FLOAT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, ARYTM_2, ARYTM_3,
   XXREAL_3, NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0, INT_1, COUNTERS, COMPLEX1, FINSET_1,
   PREPOWER, POWER;
 constructors ARYTM_2, ARYTM_3, NUMBERS, XCMPLX_0, XXREAL_0, XXREAL_3, XREAL_0, INT_1,
   COMPLEX1, FINSET_1, COUNTERS, PREPOWER, POWER;
 registrations ORDINAL1, XBOOLE_0, COUNTERS, NUMBER01,
   XCMPLX_0, XXREAL_0, XREAL_0, XXREAL_3, FINSET_1, RAT_1, INT_1,
   FOMODEL0;
 requirements REAL, SUBSET, BOOLE, NUMERALS, ARITHM;
 theorems ARYTM_2, ARYTM_3, CARD_1, COUNTERS, ENUMSET1, FINSET_1, INT_1, NUMBERS, ORDINAL1, ORDINAL2, ORDINAL3, POWER,
   TARSKI, XBOOLE_0, XBOOLE_1, XREAL_0, XREAL_1, XXREAL_0, XXREAL_3, XTUPLE_0, ZFMISC_1;

begin :: Preliminaries

definition
  let IT be Real;
  attr IT is valid_radix means :Def1:
  IT > 1;
end;

registration
  cluster valid_radix for Real;
  existence
  proof
    take x=2;
    thus thesis by Def1;
  end;
end;

registration
  cluster valid_radix -> positive for Real;
  coherence by Def1, XXREAL_0:def 6;
end;

reserve b for valid_radix Real;

theorem Th1:
  for x being positive Real
  for N being Integer
  holds (b to_power N <= x & x < b to_power (N + 1))
  iff N = [\ log(b, x) /]
proof
  let x be positive Real;
  let N be Integer;
  thus (b to_power N <= x & x < b to_power (N + 1)) implies N = [\ log(b, x) /]
  proof
    assume A1: b to_power N <= x;
    assume A2: x < b to_power (N + 1);
    A3: b <> 1 & b > 1 by Def1;
    
    A4: N <= log(b, x)
    proof
      b to_power N = x or b to_power N < x by A1, XXREAL_0:1;
      then per cases;
      suppose b to_power N = x;
        hence thesis by A3, POWER:def 3;
      end;
      suppose A5: b to_power N < x;
        A6: b to_power N > 0 by POWER:34;
        then N = log(b, b to_power N) by A3, POWER:def 3;
        hence thesis by A3, A5, A6, POWER:57;
      end;
    end;
    log(b,x) < N + 1
    proof
      b to_power (N + 1) > 0 by POWER:34;
      then N + 1 = log(b, b to_power (N + 1)) by A3, POWER:def 3;
      hence log(b,x) < (N+1) by A2, A3, POWER:57;
    end;
    then log(b,x) - 1 < (N + 1) - 1 by XREAL_1:14;
    hence thesis by A4, INT_1:def 6;
  end;
  thus N = [\ log(b, x) /] implies (b to_power N <= x & x < b to_power (N + 1))
  proof
    assume N = [\ log(b, x) /];
    then N <= log(b, x) & log(b,x) - 1 < N by INT_1:def 6;
    then N <= log(b, x) & log(b,x) - 1 + 1 < N + 1 by XREAL_1:8;
    then A1: N <= log(b, x) & log(b, x) < N + 1;
    A2: b to_power N <= b to_power (log(b,x))
      & b to_power (log(b,x)) < b to_power (N + 1)
    proof
      B1: b > 1 by Def1;
      thus b to_power N <= b to_power (log(b,x))
      proof
        per cases by A1, XXREAL_0:1;
        suppose N = log(b, x);
          hence thesis;
        end;
        suppose N < log(b, x);
          hence thesis by B1, POWER:39;
        end;
      end;
      thus b to_power (log(b,x)) < b to_power (N + 1) by A1, B1, POWER:39;
    end;
    b > 0 & b <> 1 by Def1;
    hence (b to_power N <= x & x < b to_power (N + 1)) by A2, POWER:def 3;
  end;
end;

theorem Th2:
  for x being positive Real
  holds 1 <= x * (b to_power (-[\ log(b, x) /]))
           & x * (b to_power (-[\ log(b, x) /])) < b
proof
  let x be positive Real;
  set N = [\ log(b, x) /];
  A1: b > 0 & b <> 1 by Def1;
  A2: b to_power N > 0 by POWER:34;
  A3: (b to_power N) * (b to_power (- N))
     = b to_power (N + (- N)) by POWER:27
    .= 1 by POWER:24;

  thus 1 <= x * (b to_power (- N))
  proof
    set z = b to_power N;
    1 / z = b to_power (- N) by POWER:28;
    hence 1 <= x * (b to_power (- N)) by A2, A3, Th1, XREAL_1:64;
  end;

  thus x * (b to_power (- N)) < b
  proof
    b to_power (N + 1) = (b to_power 1) * (b to_power N) by POWER:27
                      .= b * (b to_power N) by POWER:25;
    then B1: (b to_power (N + 1)) * (b to_power (- N))
     = b * ((b to_power N) * (b to_power (- N)))
    .= b by A3;
    0 < (b to_power (- N)) by POWER:34;
    hence x * (b to_power (- N)) < b by Th1, B1, XREAL_1:68;
  end;
end;

definition
  func ExtINT -> Subset of ExtREAL equals
  INT \/ {-infty,+infty};
  coherence
  proof
    INT c= REAL & REAL c= ExtREAL by XBOOLE_0:def 8, NUMBERS:5,31; then
    A1: INT c= ExtREAL by XBOOLE_1:1;
    {-infty,+infty} c= ExtREAL by XBOOLE_1:7, XXREAL_0:def 4;
    hence thesis by A1, XBOOLE_1:8;
  end;
end;

theorem Th2:
  INT c< ExtINT & ExtNAT c< ExtINT & ExtINT c< ExtREAL
proof
  thus INT c< ExtINT
  proof
    +infty in {+infty,-infty} by TARSKI:def 2; then
    A1: +infty in ExtINT by XBOOLE_0:def 3;
    not +infty in INT;
    hence thesis by A1, XBOOLE_0:def 8, XBOOLE_1:7;
  end;
  thus ExtNAT c< ExtINT
  proof
    -1 in INT & not -1 in NAT & not -1 in {+infty} by INT_1:def 1;
    then A2: -1 in ExtINT & not -1 in ExtNAT by XBOOLE_0:def 3;
    NAT c= INT & {+infty} c= {-infty,+infty} by NUMBERS:17, ZFMISC_1:7;
    hence thesis by A2, COUNTERS:def 1, XBOOLE_1:13, XBOOLE_0:def 8;
  end;
  thus ExtINT c< ExtREAL
  proof
    not REAL c= INT by XBOOLE_0:def 10, NUMBERS:15,25;
    then consider x being object such that
    A3: x in REAL & not x in INT
    by TARSKI:def 3; 
    not x in {-infty,+infty} by A3, TARSKI:def 2;
    then x in ExtREAL & not x in ExtINT by A3, XXREAL_0:def 4, XBOOLE_0:def 3;
    hence thesis by XBOOLE_0:def 8;
  end;
end;

registration
  cluster ExtINT -> non empty infinite;
  coherence by Th2, FINSET_1:1, XBOOLE_0:def 8;
end;

definition
  let x be object;
  attr x is ext-integer means :Def2:
  x in ExtINT;
end;

registration
  cluster +infty -> ext-integer;
  coherence
  proof
    +infty in {+infty,-infty} by TARSKI:def 2;
    hence thesis by XBOOLE_0:def 3;
  end;
  cluster -infty -> ext-integer;
  coherence
  proof
    -infty in {+infty,-infty} by TARSKI:def 2;
    hence thesis by XBOOLE_0:def 3;
  end;
  cluster ext-integer -> ext-real for object;
  coherence;
  cluster ext-natural -> ext-integer for object;
  coherence
  proof
    let x be object;
    assume x is ext-natural;
    then x in ExtNAT by COUNTERS:def 2;
    hence thesis by Th2, TARSKI:def 3, XBOOLE_0:def 8;
  end;
end;

registration
  cluster zero ext-integer for object;
  existence
  proof
    take 0;
    thus thesis;
  end;
  cluster non zero ext-integer for object;
  existence
  proof
    take 1;
    thus thesis;
  end;
  cluster ext-integer for set;
  existence
  proof
    take 0;
    thus thesis;
  end;
  cluster -> ext-integer for Element of ExtINT;
  coherence;
  cluster -> ext-integer for Element of ExtNAT;
  coherence;
end;

definition
  mode ExtInt is ext-integer ExtReal;
end;

registration
  sethood of ExtInt
  proof
    take ExtINT;
    thus thesis by Def2;
  end;
end;

theorem Th4:
  for x being object
  holds x is ExtInt iff (x is Integer or x = -infty or x = +infty)
proof
  let x be object;
  thus x is ExtInt implies (x is Integer or x = -infty or x = +infty)
  proof
    assume A1: x is ExtInt;
    assume A2: not x is Integer & not x = -infty;
    x in INT \/ {-infty, +infty} by A1, Def2;
    then x in INT or x in {-infty, +infty} by XBOOLE_0:def 3;
    hence x = +infty by A2, TARSKI:def 2;
  end;
  thus (x is Integer or x = -infty or x = +infty) implies x is ExtInt
  proof
    assume x is Integer or x = -infty or x = +infty;
    then x in INT or x in {-infty,+infty} by INT_1:def 2, TARSKI:def 2;
    then x in INT \/ {-infty,+infty} by XBOOLE_0:def 3;
    hence x is ExtInt by Def2;
  end;
end;

registration
  cluster zero -> ext-integer for object;
  coherence;
  cluster integer -> ext-integer for object;
  coherence by Th4;
end;

registration
  cluster natural -> ext-integer for object;
  coherence;
end;

registration
  cluster positive for ExtInt;
  existence
  proof
    take 1;
    thus thesis;
  end;
  cluster non positive for ExtInt;
  existence
  proof
    take -1;
    thus thesis;
  end;
  cluster negative for ExtInt;
  existence
  proof
    take -1;
    thus thesis;
  end;
  cluster non negative for ExtInt;
  existence
  proof
    take 1;
    thus thesis;
  end;
end;

registration
  let m be ExtInt;
  cluster - m -> ext-integer;
  coherence
  proof
    per cases by Th4;
    suppose m is Integer;
      then reconsider M=m as Integer;
      -M is Integer;
      hence thesis by XXREAL_3:def 3;
    end;
    suppose m=-infty;
      hence thesis by XXREAL_3:def 3;
    end;
    suppose m=+infty;
      hence thesis by XXREAL_3:def 3;
    end;
  end;
end;

registration
  let m, n be ExtInt;
  cluster min(m, n) -> ext-integer;
  coherence by XXREAL_0:def 9;
  cluster max(m, n) -> ext-integer;
  coherence by XXREAL_0:def 10;
  cluster m + n -> ext-integer;
  coherence
  proof
    per cases by Th4;
    suppose A1: m is Integer;
      then reconsider M=m as Integer;
      per cases by Th4;
      suppose n is Integer;
        then reconsider N=n as Integer;
        M + N is Integer;
        hence thesis by XXREAL_3:def 2;
      end;
      suppose n=-infty;
        hence thesis by A1, XXREAL_3:def 2;
      end;
      suppose n=+infty;
        hence thesis by A1, XXREAL_3:def 2;
      end;
    end;
    suppose A2: m=-infty;
      per cases by Th4;
      suppose n is Integer;
        hence thesis by A2, XXREAL_3:def 2;
      end;
      suppose n=-infty;
        hence thesis by A2, XXREAL_3:def 2;
      end;
      suppose n=+infty;
        hence thesis by A2;
      end;
    end;
    suppose A3: m=+infty;
      per cases by Th4;
      suppose n is Integer;
        hence thesis by A3, XXREAL_3:def 2;
      end;
      suppose n=-infty;
        hence thesis by A3;
      end;
      suppose n=+infty;
        hence thesis by A3;
      end;
    end;
  end;
  cluster m * n -> ext-integer;
  coherence
  proof
    per cases by Th4;
    suppose m is Integer;
      then reconsider M=m as Integer;
      per cases by Th4;
      suppose n is Integer;
        then reconsider N=n as Integer;
        M * N is Integer;
        hence thesis by XXREAL_3:def 5;
      end;
      suppose B1: n=-infty;
        m is positive or m is negative or m is zero;
        hence thesis by B1, XXREAL_3:def 5;
      end;
      suppose B2: n=+infty;
        m is positive or m is negative or m is zero;
        hence thesis by B2, XXREAL_3:def 5;
      end;
    end;
    suppose A2: m=-infty;
      per cases by Th4;
      suppose n is Integer;
        n is positive or n is negative or n is zero;
        hence thesis by A2, XXREAL_3:def 5;
      end;
      suppose n=-infty;
        hence thesis by A2, XXREAL_3:def 5;
      end;
      suppose n=+infty;
        hence thesis by A2, XXREAL_3:def 5;
      end;
    end;
    suppose A3: m=+infty;
      per cases by Th4;
      suppose n is Integer;
        n is positive or n is negative or n is zero;
        hence thesis by A3, XXREAL_3:def 5;
      end;
      suppose n=-infty;
        hence thesis by A3, XXREAL_3:def 5;
      end;
      suppose n=+infty;
        hence thesis by A3;
      end;
    end;
  end;
end;

registration
  let m, n be ExtInt;
  cluster m - n -> ext-integer;
  coherence
  proof
    (- n) is ext-integer & m + (- n) is ext-integer &
    m - n = m + (- n) by XXREAL_3:def 4;
    hence thesis;
  end;
end;

registration
  cluster non negative -> ext-natural for ExtInt;
  coherence
  proof
    let x be ExtInt;
    assume A1: x is non negative;
    x is Integer or x = -infty or x = +infty by Th4;
    hence thesis by A1;
  end;
end;

theorem
  for x being object
  holds x is positive ExtInt iff (x is positive Integer or x = +infty) by Th4;

theorem
  for x being object
  holds x is negative ExtInt iff (x is negative Integer or x = -infty) by Th4;

begin :: 3. Floating-point formats

definition
  func -0 -> object equals [0,0];
  coherence;
end;

theorem Th4:
  for n being Nat
  holds [n,0] <> +infty & [n,0] <> -infty
proof
  let n be Nat;
  A1: n in REAL by NUMBERS:19, TARSKI:def 3, ORDINAL1:def 12;
  +infty = [n,0] implies contradiction
  proof
    assume A2: +infty = [n,0];
    then +infty = {{n}, {n,0}} by TARSKI:def 5;
    then n = {n} or n = {n,0};
    then per cases;
    suppose n = {n};
      hence contradiction by ZFMISC_1:140;
    end;
    suppose n = {n,0};
      then n in n or n in 0 by TARSKI:def 2;
      hence contradiction by ORDINAL1:def 13;
    end;
  end;
  hence [n,0] <> +infty;
  thus [n,0] <> -infty by A1, XXREAL_0:def 3, XTUPLE_0:1, ORDINAL1:def 13;
end;

theorem Th5:
  not -0 in ExtREAL
proof
  [0,0] <> +infty & [0,0] <> -infty by Th4;
  then not (-0 in REAL or -0 in {+infty, -infty})
  by NUMBERS:def 1, ZFMISC_1:56, TARSKI:def 2;
  hence thesis by NUMBERS:def 5, XBOOLE_0:def 3, XXREAL_0:def 2,def 3;
end;

Lm1:
  for n being Nat
  holds not [n,0] in RAT+
proof
  let n be Nat;
  assume A1: [n,0] in RAT+;
  n in omega by ORDINAL1:def 12;
  then 0 <> {} by A1, ARYTM_3:33;
  hence contradiction by ORDINAL1:def 13;
end;

Lm2:
  for a,b being Nat
  st a = {b}
  holds b = {}
proof
  let a,b be Nat;
  assume A1: a = {b};
  then consider c being Nat such that
  A2: a = succ c by CARD_1:36;
  {b} = c \/ {c} by A1, A2, ORDINAL1:def 1;
  then c = {} by ZFMISC_1:38, ZFMISC_1:140;
  then a = {} \/ {{}} by A2, ORDINAL1:def 1;
  hence thesis by A1, ZFMISC_1:3;
end;

Lm3:
  for i being Nat st i <> 0
  holds not {i} in RAT+
proof
  let i be Nat such that
  A1: i <> 0;
  assume A2: {i} in RAT+;
  then per cases by ARYTM_3:29;
  suppose {i} in omega;
    then {} in {i} by ORDINAL3:8;
    hence contradiction by A1, ORDINAL1:def 13, TARSKI:def 1;
  end;
  suppose ex a,b being Element of omega st ({i} = [a,b] &
    a,b are_coprime & b <> {} & b <> 1);
    then consider a,b being Element of omega such that
    A3: ({i} = [a,b] & a,b are_coprime & b <> {} & b <> 1);
    {i} = {{a}, {a,b}} by A3, TARSKI:def 5;
    then {a} = {a,b} by ZFMISC_1:5;
    then A4: a = b by ZFMISC_1:5;
    then {i} = {{b}, {b,b}} by A3, TARSKI:def 5
            .= {{b}, {b}} by ENUMSET1:29
            .= {{b}} by ENUMSET1:29;
    hence contradiction by A3, Lm2, ZFMISC_1:3;
  end;
end;

Lm4:
  for i being Nat st i <> 0
  holds not [i,0] in DEDEKIND_CUTS
proof
  let i be Nat such that
  A1: i <> 0;
  assume [i,0] in DEDEKIND_CUTS;
  then [i,0] in {A where A is Subset of RAT+ : for r being Element of RAT+
  st r in A holds ((for s being Element of RAT+ st s <=' r holds s in A)
                   & ex s being Element of RAT+ st (s in A & r < s)) }
  by ARYTM_2:def 1;
  then consider A being Subset of RAT+ such that
  A2: [i,0] = A
    & for r being Element of RAT+ st r in A
      holds (for s being Element of RAT+ st s <=' r holds s in A)
          & ex s being Element of RAT+ st s in A & r < s;
  A = {{i}, {i,0}} by A2, TARSKI:def 5;
  then {i} in RAT+ & {i,0} in RAT+ by ZFMISC_1:32;
  hence contradiction by A1, Lm3;
end;

theorem Th6:
  for i being Nat
  holds not [i,0] in ExtREAL
proof
  let i be Nat;
  A1: not [i,0] in REAL
  proof
    per cases;
    suppose i = 0;
      hence thesis by Th5, NUMBERS:def 5, XBOOLE_0:def 3;
    end;
    suppose A1: i <> 0;
      then not ([i,0] in RAT+ or [i,0] in DEDEKIND_CUTS) by Lm1,Lm4;
      then A2: not [i,0] in REAL+ by ARYTM_2:def 2, XBOOLE_0:def 3;
      not [i,0] in [:{0},REAL+:] by A1, ZFMISC_1:105;
      hence thesis by A2, XBOOLE_0:def 3, NUMBERS:def 1;
    end;
  end;
  [i,0] <> +infty & [i,0] <> -infty by Th4;
  then not [i,0] in {+infty,-infty} by TARSKI:def 2;
  then not [i,0] in REAL \/ {+infty,-infty} by A1, XBOOLE_0:def 3;
  hence not [i,0] in ExtREAL by NUMBERS:def 5, XXREAL_0:def 2,def 3;
end;

definition
  func NaN -> object equals [1,0];
  coherence;
end;

theorem
  not NaN in ExtREAL by Th6;

reserve beta for valid_radix Real;
reserve p for positive Integer;
reserve eMin for negative ExtInt;
reserve eMax for positive ExtNat;

definition
  let b, p, eMin, eMax;
  func FLOAT_NUMBER(b, p, eMin, eMax) -> Subset of ExtREAL equals
  {x where x is Real : ex M, e being Integer
   st x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
   & eMin <= e & e <= eMax } \/ {+infty, -infty};
  coherence
  proof
    set NUM = {x where x is Real : ex M, e being Integer
    st x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
    & eMin <= e & e <= eMax };
    set IT = NUM \/ {+infty, -infty};
    for x being object st x in IT holds x in ExtREAL
    proof
      let x be object;
      assume Z1: x in IT;
      then per cases by XBOOLE_0:def 3;
      suppose A1: x in NUM;
        then ex y being Real st x = y & ex M, e being Integer
        st y = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
        & eMin <= e & e <= eMax;
        then x in REAL by XREAL_0:def 1;
        hence x in ExtREAL by XBOOLE_0:def 3, XXREAL_0:def 4;
      end;
      suppose A2: x in {-infty, +infty};
        hence x in ExtREAL by XBOOLE_0:def 3, XXREAL_0:def 4;
      end;
    end;
    hence thesis by TARSKI:def 3;
  end;
end;

definition
  let beta, p, eMin, eMax;
  func FLOAT(beta, p, eMin, eMax) -> set equals
  FLOAT_NUMBER(beta, p, eMin, eMax) \/ {-0, NaN};
  coherence;
end;
