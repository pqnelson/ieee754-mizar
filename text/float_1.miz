:: Floating-point Arithmetic
:: by Alexander M. Nelson
::
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ
 vocabularies NUMBERS, ORDINAL1, CARD_1, SUBSET_1, XBOOLE_0, ARYTM_2, ARYTM_3,
   ZFMISC_1, XCMPLX_0, XXREAL_0, TARSKI, FUNCT_7, RELAT_1,
   REAL_1, INT_1, PREPOWER, POWER, ARYTM_1, NAT_1,
   FLOAT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, ARYTM_2, ARYTM_3,
   NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0, INT_1,
   PREPOWER, POWER;
 constructors ARYTM_2, ARYTM_3, NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0, INT_1,
   PREPOWER, POWER;
 registrations ORDINAL1, XBOOLE_0, XCMPLX_0, XXREAL_0, XREAL_0, INT_1, RAT_1;
 requirements REAL, SUBSET, BOOLE, NUMERALS, ARITHM;
 theorems ARYTM_2, ARYTM_3, CARD_1, ENUMSET1, INT_1, NUMBERS, ORDINAL1, ORDINAL2, ORDINAL3, POWER,
   TARSKI, XBOOLE_0, XREAL_1, XXREAL_0, XTUPLE_0, ZFMISC_1;

begin :: Preliminaries

definition
  let IT be Real;
  attr IT is valid_radix means :Def1:
  IT > 1;
end;

registration
  cluster valid_radix for Real;
  existence
  proof
    take x=2;
    thus thesis by Def1;
  end;
end;

registration
  cluster valid_radix -> positive for Real;
  coherence by Def1, XXREAL_0:def 6;
end;

reserve b for valid_radix Real;

theorem Th1:
  for x being positive Real
  for N being Integer
  holds (b to_power N <= x & x < b to_power (N + 1))
  iff N = [\ log(b, x) /]
proof
  let x be positive Real;
  let N be Integer;
  thus (b to_power N <= x & x < b to_power (N + 1)) implies N = [\ log(b, x) /]
  proof
    assume A1: b to_power N <= x;
    assume A2: x < b to_power (N + 1);
    A3: b <> 1 & b > 1 by Def1;
    
    A4: N <= log(b, x)
    proof
      b to_power N = x or b to_power N < x by A1, XXREAL_0:1;
      then per cases;
      suppose b to_power N = x;
        hence thesis by A3, POWER:def 3;
      end;
      suppose A5: b to_power N < x;
        A6: b to_power N > 0 by POWER:34;
        then N = log(b, b to_power N) by A3, POWER:def 3;
        hence thesis by A3, A5, A6, POWER:57;
      end;
    end;
    log(b,x) < N + 1
    proof
      b to_power (N + 1) > 0 by POWER:34;
      then N + 1 = log(b, b to_power (N + 1)) by A3, POWER:def 3;
      hence log(b,x) < (N+1) by A2, A3, POWER:57;
    end;
    then log(b,x) - 1 < (N + 1) - 1 by XREAL_1:14;
    hence thesis by A4, INT_1:def 6;
  end;
  thus N = [\ log(b, x) /] implies (b to_power N <= x & x < b to_power (N + 1))
  proof
    assume N = [\ log(b, x) /];
    then N <= log(b, x) & log(b,x) - 1 < N by INT_1:def 6;
    then N <= log(b, x) & log(b,x) - 1 + 1 < N + 1 by XREAL_1:8;
    then A1: N <= log(b, x) & log(b, x) < N + 1;
    A2: b to_power N <= b to_power (log(b,x))
      & b to_power (log(b,x)) < b to_power (N + 1)
    proof
      B1: b > 1 by Def1;
      thus b to_power N <= b to_power (log(b,x))
      proof
        per cases by A1, XXREAL_0:1;
        suppose N = log(b, x);
          hence thesis;
        end;
        suppose N < log(b, x);
          hence thesis by B1, POWER:39;
        end;
      end;
      thus b to_power (log(b,x)) < b to_power (N + 1) by A1, B1, POWER:39;
    end;
    b > 0 & b <> 1 by Def1;
    hence (b to_power N <= x & x < b to_power (N + 1)) by A2, POWER:def 3;
  end;
end;

theorem Th2:
  for x being positive Real
  holds 1 <= x * (b to_power (-[\ log(b, x) /]))
           & x * (b to_power (-[\ log(b, x) /])) < b
proof
  let x be positive Real;
  set N = [\ log(b, x) /];
  A1: b > 0 & b <> 1 by Def1;
  A2: b to_power N > 0 by POWER:34;
  A3: (b to_power N) * (b to_power (- N))
     = b to_power (N + (- N)) by POWER:27
    .= 1 by POWER:24;

  thus 1 <= x * (b to_power (- N))
  proof
    set z = b to_power N;
    1 / z = b to_power (- N) by POWER:28;
    hence 1 <= x * (b to_power (- N)) by A2, A3, Th1, XREAL_1:64;
  end;

  thus x * (b to_power (- N)) < b
  proof
    b to_power (N + 1) = (b to_power 1) * (b to_power N) by POWER:27
                      .= b * (b to_power N) by POWER:25;
    then B1: (b to_power (N + 1)) * (b to_power (- N))
     = b * ((b to_power N) * (b to_power (- N)))
    .= b by A3;
    0 < (b to_power (- N)) by POWER:34;
    hence x * (b to_power (- N)) < b by Th1, B1, XREAL_1:68;
  end;
end;


begin :: 3. Floating-point formats

definition
  func -0 -> object equals [0,0];
  coherence;
end;

theorem Th4:
  for n being Nat
  holds [n,0] <> +infty & [n,0] <> -infty
proof
  let n be Nat;
  A1: n in REAL by NUMBERS:19, TARSKI:def 3, ORDINAL1:def 12;
  +infty = [n,0] implies contradiction
  proof
    assume A2: +infty = [n,0];
    then +infty = {{n}, {n,0}} by TARSKI:def 5;
    then n = {n} or n = {n,0} by A1, TARSKI:def 2, XXREAL_0:def 2;
    then per cases;
    suppose n = {n};
      hence contradiction by ZFMISC_1:140;
    end;
    suppose n = {n,0};
      then n in n or n in 0 by TARSKI:def 2;
      hence contradiction by ORDINAL1:def 13;
    end;
  end;
  hence [n,0] <> +infty;
  -infty = [n,0] implies contradiction
  by A1, XXREAL_0:def 3, XTUPLE_0:1, ORDINAL1:def 13;
  hence [n,0] <> -infty;
end;

theorem Th5:
  not -0 in ExtREAL
proof
  A1: not -0 in REAL by NUMBERS:def 1, ZFMISC_1:56;
  [0,0] <> +infty & [0,0] <> -infty by Th4;
  then not -0 in {+infty, -infty} by TARSKI:def 2;
  then not (-0 in REAL or -0 in {+infty, -infty}) by A1;
  then not -0 in REAL \/ {+infty, -infty} by XBOOLE_0:def 3;
  hence thesis by NUMBERS:def 5, XXREAL_0:def 2, XXREAL_0:def 3;
end;

Lm1:
  for n being Nat
  holds not [n,0] in RAT+
proof
  let n be Nat;
  assume A1: [n,0] in RAT+;
  n in omega by ORDINAL1:def 12;
  then 0 <> {} by A1, ARYTM_3:33;
  hence contradiction by ORDINAL1:def 13;
end;

Lm2:
  for a,b being Nat
  st a = {b}
  holds b = {}
proof
  let a,b be Nat;
  assume A1: a = {b};
  then consider c being Nat such that
  A2: a = succ c by CARD_1:36;
  {b} = c \/ {c} by A1, A2, ORDINAL1:def 1;
  then c = {} by ZFMISC_1:38, ZFMISC_1:140;
  then a = {} \/ {{}} by A2, ORDINAL1:def 1;
  hence thesis by A1, ZFMISC_1:3;
end;

Lm3:
  for i being Nat st i <> 0
  holds not {i} in RAT+
proof
  let i be Nat such that
  A1: i <> 0;
  assume A2: {i} in RAT+;
  then per cases by ARYTM_3:29;
  suppose {i} in omega;
    then {} in {i} by ORDINAL3:8;
    hence contradiction by A1, ORDINAL1:def 13, TARSKI:def 1;
  end;
  suppose ex a,b being Element of omega st ({i} = [a,b] &
    a,b are_coprime & b <> {} & b <> 1);
    then consider a,b being Element of omega such that
    A3: ({i} = [a,b] & a,b are_coprime & b <> {} & b <> 1);
    {i} = {{a}, {a,b}} by A3, TARSKI:def 5;
    then {a} = {a,b} by ZFMISC_1:5;
    then A4: a = b by ZFMISC_1:5;
    then {i} = {{b}, {b,b}} by A3, TARSKI:def 5
            .= {{b}, {b}} by ENUMSET1:29
            .= {{b}} by ENUMSET1:29;
    hence contradiction by A3, Lm2, ZFMISC_1:3;
  end;
end;

Lm4:
  for i being Nat st i <> 0
  holds not [i,0] in DEDEKIND_CUTS
proof
  let i be Nat such that
  A1: i <> 0;
  assume [i,0] in DEDEKIND_CUTS;
  then [i,0] in {A where A is Subset of RAT+ : for r being Element of RAT+
  st r in A holds ((for s being Element of RAT+ st s <=' r holds s in A)
                   & ex s being Element of RAT+ st (s in A & r < s)) }
  by ARYTM_2:def 1;
  then consider A being Subset of RAT+ such that
  A2: [i,0] = A
    & for r being Element of RAT+ st r in A
      holds (for s being Element of RAT+ st s <=' r holds s in A)
          & ex s being Element of RAT+ st s in A & r < s;
  A = {{i}, {i,0}} by A2, TARSKI:def 5;
  then {i} in RAT+ & {i,0} in RAT+ by ZFMISC_1:32;
  hence contradiction by A1, Lm3;
end;

theorem Th6:
  for i being Nat
  holds not [i,0] in ExtREAL
proof
  let i be Nat;
  A1: not [i,0] in REAL
  proof
    per cases;
    suppose i = 0;
      hence thesis by Th5, NUMBERS:def 5, XBOOLE_0:def 3;
    end;
    suppose A1: i <> 0;
      then not ([i,0] in RAT+ or [i,0] in DEDEKIND_CUTS) by Lm1,Lm4;
      then A2: not [i,0] in REAL+ by ARYTM_2:def 2, XBOOLE_0:def 3;
      not [i,0] in [:{0},REAL+:] by A1, ZFMISC_1:105;
      hence thesis by A2, XBOOLE_0:def 3, NUMBERS:def 1;
    end;
  end;
  [i,0] <> +infty & [i,0] <> -infty by Th4;
  then not [i,0] in {+infty,-infty} by TARSKI:def 2;
  then not [i,0] in REAL \/ {+infty,-infty} by A1, XBOOLE_0:def 3;
  hence not [i,0] in ExtREAL by NUMBERS:def 5, XXREAL_0:def 2,def 3;
end;

definition
  func NaN -> object equals [1,0];
  coherence;
end;

theorem
  not NaN in ExtREAL by Th6;
