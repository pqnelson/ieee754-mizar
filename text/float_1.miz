:: Floating-point Arithmetic
:: by Alexander M. Nelson
::
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ
 vocabularies NUMBERS, ORDINAL1, CARD_1, CARD_3, SUBSET_1, XBOOLE_0,
   ARYTM_2, ARYTM_3, ZFMISC_1, XCMPLX_0, XREAL_0, XXREAL_0, TARSKI,
   FUNCT_1, FUNCT_7, RELAT_1, REAL_1, INT_1, PREPOWER, POWER, ARYTM_1,
   NAT_1, COUNTERS, COMPLEX1, FINSEQ_1, FINSET_1, FUNCOP_1, RFINSEQ,
   NEWTON, PARTFUN3, PRE_TOPC, FUZNUM_1, SEQ_1, ORDINAL2, SEQ_2, SERIES_1,
   NUMERAL1, AFINSQ_1, ORDINAL4, VALUED_0, VALUED_1, FLOAT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, ORDINAL4,
   ARYTM_2, ARYTM_3, FINSEQ_1, RELSET_1, RELAT_1, PARTFUN1, PARTFUN3,
   FUNCOP_1, AFINSQ_1, AFINSQ_2, ENUMSET1, XXREAL_2, XXREAL_3, NUMBERS,
   XCMPLX_0, XXREAL_0, XREAL_0, NEWTON, FUNCT_1, FUNCT_2, NAT_1, INT_1,
   COUNTERS, COMPLEX1, FINSET_1, SEQ_1, MEMBERED, SEQ_2, SEQ_4,
   SERIES_1, NUMERAL1, VALUED_0, VALUED_1, PREPOWER, POWER;
 constructors FINSEQ_1, FUNCOP_1, BINOP_2, ORDINAL4, ARYTM_2, ARYTM_3,
   NUMBERS, XCMPLX_0, XXREAL_0, XXREAL_1, XXREAL_2, XXREAL_3, XREAL_0,
   RELSET_1, FUNCT_1, FUNCT_2, NAT_1, INT_1, ENUMSET1, COMPLEX1, NEWTON,
   FINSET_1, COUNTERS, PREPOWER, POWER, PARTFUN1, PARTFUN3, SERIES_1,
   MEMBERED, NUMERAL1, RECDEF_1, AFINSQ_1, NAT_D, AFINSQ_2, VALUED_0,
   VALUED_1, COMSEQ_2, SEQ_2, SEQ_4, SEQ_1;
 registrations ORDINAL1, XBOOLE_0, COUNTERS, NUMBERS, NUMBER01,
   XCMPLX_0, XXREAL_0, XREAL_0, XXREAL_3, FINSET_1, RAT_1, NAT_1, INT_1,
   RELSET_1, AFINSQ_1, AFINSQ_2, VALUED_0, VALUED_1, FUNCT_2, SEQ_1,
   SEQ_2, FOMODEL0, NEWTON, POWER, MEMBERED;
 requirements REAL, SUBSET, BOOLE, NUMERALS, ARITHM;
 theorems AFINSQ_1, AFINSQ_2, ARYTM_2, ARYTM_3, CARD_1, COMPLEX1,
   COUNTERS, ENUMSET1, FINSET_1, FUNCOP_1, FUNCT_1, FUNCT_2, INT_1,
   NAT_1, NUMERAL1, NUMBERS, ORDINAL1, ORDINAL3, PARTFUN3, POWER,
   PREPOWER, RELAT_1, SEQ_1, SEQ_2, SERIES_1, SUBSET_1, TARSKI,
   VALUED_1, XBOOLE_0, XBOOLE_1, XCMPLX_0, XCMPLX_1, XREAL_0, XREAL_1,
   XXREAL_0, XXREAL_3, XTUPLE_0, ZFMISC_1;
 schemes AFINSQ_1, NAT_1, SEQ_1;

begin :: Preliminaries

definition
  let IT be Real;
  attr IT is valid_radix means :Def1:
  IT > 1;
end;

registration
  cluster valid_radix for Real;
  existence
  proof
    take x=2;
    thus thesis by Def1;
  end;
end;

registration
  cluster valid_radix for Nat;
  existence
  proof
    take 2;
    thus thesis;
  end;
end;

registration
  cluster valid_radix -> positive for Real;
  coherence by Def1, XXREAL_0:def 6;
end;

registration
  let x be positive Real;
  let y be Real;
  cluster x to_power y -> positive;
  coherence by POWER:34;
end;

theorem Th1:
  for x,y,z being Real
  st x <= y & z > 1
  holds z to_power x <= z to_power y
proof
  let x,y,z be Real;
  assume A1: x <= y;
  assume A2: z > 1;
  x < y or x = y by A1, XXREAL_0:1;
  hence thesis by A2, POWER:39;
end;

theorem ThNatPowers:
  for x being Real
  for y being Real
  st x in NAT & y in NAT
  holds x to_power y in NAT
proof
  let x be Real;
  let y be Real;
  assume A1: x in NAT;
  assume A2: y in NAT;
  reconsider X=x, Y=y as Nat by A1,A2;
  X to_power Y = X |^ Y by POWER:41;
  hence x to_power y in NAT by ORDINAL1:def 12;
end;

reserve b for valid_radix Real;

theorem Th1b:
  for x being positive Real
  for N being Integer
  holds (b to_power N <= x & x < b to_power (N + 1))
  iff N = [\ log(b, x) /]
proof
  let x be positive Real;
  let N be Integer;
  thus (b to_power N <= x & x < b to_power (N + 1)) implies N = [\ log(b, x) /]
  proof
    assume A1: b to_power N <= x;
    assume A2: x < b to_power (N + 1);
    A3: b <> 1 & b > 1 by Def1;
    
    A4: N <= log(b, x)
    proof
      b to_power N = x or b to_power N < x by A1, XXREAL_0:1;
      then per cases;
      suppose b to_power N = x;
        hence thesis by A3, POWER:def 3;
      end;
      suppose A5: b to_power N < x;
        A6: b to_power N > 0 by POWER:34;
        then N = log(b, b to_power N) by A3, POWER:def 3;
        hence thesis by A3, A5, A6, POWER:57;
      end;
    end;
    log(b,x) < N + 1
    proof
      b to_power (N + 1) > 0 by POWER:34;
      then N + 1 = log(b, b to_power (N + 1)) by A3, POWER:def 3;
      hence log(b,x) < (N+1) by A2, A3, POWER:57;
    end;
    then log(b,x) - 1 < (N + 1) - 1 by XREAL_1:14;
    hence thesis by A4, INT_1:def 6;
  end;
  thus N = [\ log(b, x) /] implies (b to_power N <= x & x < b to_power (N + 1))
  proof
    assume N = [\ log(b, x) /];
    then N <= log(b, x) & log(b,x) - 1 < N by INT_1:def 6;
    then N <= log(b, x) & log(b,x) - 1 + 1 < N + 1 by XREAL_1:8;
    then A1: N <= log(b, x) & log(b, x) < N + 1;
    A2: b to_power N <= b to_power (log(b,x))
      & b to_power (log(b,x)) < b to_power (N + 1)
    proof
      B1: b > 1 by Def1;
      thus b to_power N <= b to_power (log(b,x))
      proof
        per cases by A1, XXREAL_0:1;
        suppose N = log(b, x);
          hence thesis;
        end;
        suppose N < log(b, x);
          hence thesis by B1, POWER:39;
        end;
      end;
      thus b to_power (log(b,x)) < b to_power (N + 1) by A1, B1, POWER:39;
    end;
    b > 0 & b <> 1 by Def1;
    hence (b to_power N <= x & x < b to_power (N + 1)) by A2, POWER:def 3;
  end;
end;

theorem Th2:
  for x being positive Real
  holds 1 <= x * (b to_power (-[\ log(b, x) /]))
           & x * (b to_power (-[\ log(b, x) /])) < b
proof
  let x be positive Real;
  set N = [\ log(b, x) /];
  A1: b > 0 & b <> 1 by Def1;
  A2: b to_power N > 0 by POWER:34;
  A3: (b to_power N) * (b to_power (- N))
     = b to_power (N + (- N)) by POWER:27
    .= 1 by POWER:24;

  thus 1 <= x * (b to_power (- N))
  proof
    set z = b to_power N;
    1 / z = b to_power (- N) by POWER:28;
    hence 1 <= x * (b to_power (- N)) by A2, A3, Th1b, XREAL_1:64;
  end;

  thus x * (b to_power (- N)) < b
  proof
    b to_power (N + 1) = (b to_power 1) * (b to_power N) by POWER:27
                      .= b * (b to_power N) by POWER:25;
    then B1: (b to_power (N + 1)) * (b to_power (- N))
     = b * ((b to_power N) * (b to_power (- N)))
    .= b by A3;
    0 < (b to_power (- N)) by POWER:34;
    hence x * (b to_power (- N)) < b by Th1b, B1, XREAL_1:68;
  end;
end;

theorem ThBetaExpansionExistence:
  for x being Real
  ex d, r being Real_Sequence
  st d.0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
  & r.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/]
  & for j being Nat
  holds d.(j+1) = [\ b*(r.j) /]
  & r.(j+1) = b*(r.j) - [\ b*(r.j) /]
proof
  let x be Real;
  reconsider d0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
  as Element of REAL by XREAL_0:def 1;
  reconsider r0 = x*(b to_power (-[\ log(b,x) /])) - d0
  as Element of REAL by XREAL_0:def 1;
  deffunc R0() = r0;
  deffunc Rrec(Nat, Real) = In(b*$2 - [\ b*$2 /], REAL);

  consider r being sequence of REAL such that
  A1: r.0 = R0() & for n being Nat holds r.(n + 1) = Rrec(n, r.n)
  from NAT_1:sch 12;
  reconsider r as Real_Sequence;
  deffunc D0() = d0;
  deffunc Drec(Nat, Real) = In([\ b*(r.$1) /], REAL);
  consider d being sequence of REAL such that
  A2: d.0 = D0() & for n being Nat holds d.(n + 1) = Drec(n, d.n)
  from NAT_1:sch 12;

  take d, r;
  thus d.0 = [\ x * (b to_power (-[\ log(b, x) /])) /] by A2;
  thus r.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/]
  by A1;
  thus for j being Nat
  holds d.(j+1) = [\ b*(r.j) /]
  & r.(j+1) = b*(r.j) - [\ b*(r.j) /]
  proof
    let j be Nat;
    thus d.(j + 1) = In([\ b*(r.j) /], REAL) by A2
                  .= [\ b*(r.j) /];
    thus r.(j + 1) = Rrec(j, r.j) by A1
                  .= b*(r.j) - [\ b*(r.j) /];
  end;
end;

theorem ThExistenceOfN:
  for epsilon being Real
  st epsilon > 0
  ex N being Nat
  st b to_power -N < epsilon
proof
  let epsilon be Real;
  assume A1: epsilon > 0;
  per cases;
  suppose A2: epsilon >= 1;
    take N=1;
    -1 < 0 & b > 1 by Def1;
    then b to_power -N < b to_power 0 by POWER:39;
    then b to_power -N < 1 by POWER:24;
    hence thesis by A2, XXREAL_0:2;
  end;
  suppose A2: epsilon < 1;
    A4: 0 < -log(b, epsilon)
    proof
      A3: 0 < epsilon & epsilon < 1 & b > 1 by A1, A2, Def1;
      then log(b,1) > log(b,epsilon) by POWER:57;
      then 0 > log(b, epsilon) by A3, POWER:51;
      hence thesis;
    end;
    consider r being Real such that
    A5: r > -log(b, epsilon)
    by XREAL_1:1;
    [/r\]+1 in NAT
    proof
      [/r\] >= 0 by A4, A5, INT_1:def 7;
      hence [/r\]+1 in NAT by INT_1:3;
    end;
    then reconsider N = [/r\]+1 as Nat;
    take N;
    A6: b > 1 by Def1; then
    A7: b to_power (log(b,epsilon)) = epsilon by A1, POWER:def 3;
    [/r\] >= r by INT_1:def 7;
    then [/r\] > -log(b,epsilon) by A5, XXREAL_0:2;
    then [/r\] + 1 > -log(b,epsilon) by XREAL_1:145;
    then -N < -(-log(b,epsilon)) by XREAL_1:24;
    hence b to_power -N < epsilon by A6,A7,POWER:39;
  end;
end;

theorem ThBetaExpansionLimit:
  for x being Real
  for d, r being Real_Sequence
  st d.0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
  & r.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/]
  & (for j being Nat
  holds d.(j+1) = [\ b*(r.j) /]
  & r.(j+1) = b*(r.j) - [\ b*(r.j) /])
  ex s being Real_Sequence
  st s.0 = d.0
  & (for j being Nat holds s.(j + 1) = (s.j) + ((d.(j + 1)) * (b to_power (-j-1))))
  & s is convergent
  & lim s = x * (b to_power (-[\ log(b, x) /]))
proof
  let x be Real;
  let d, r be Real_Sequence;
  assume A1: d.0 = [\ x * (b to_power (-[\ log(b, x) /])) /];
  assume A2: r.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/];
  assume A3: for j being Nat
  holds d.(j+1) = [\ b*(r.j) /]
  & r.(j+1) = b*(r.j) - [\ b*(r.j) /];

  reconsider d0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
  as Element of REAL by XREAL_0:def 1;
  reconsider r0 = x*(b to_power (-[\ log(b,x) /])) - d0
  as Element of REAL by XREAL_0:def 1;
  deffunc S0() = d.0;
  deffunc Srec(Nat, Real) = In($2 + ((d.($1 + 1)) * (b to_power (-$1 - 1))),
  REAL);

  consider s being sequence of REAL such that
  A4: s.0 = S0() & for n being Nat holds s.(n + 1) = Srec(n, s.n)
  from NAT_1:sch 12;
  reconsider s as Real_Sequence;

  take s;
  thus s.0 = d.0 by A4;
  thus for j being Nat
  holds s.(j + 1) = (s.j) + ((d.(j + 1)) * (b to_power (-j-1)))
  proof
    let j be Nat;
    thus s.(j + 1) = In((s.j) + ((d.(j + 1)) * (b to_power (-j-1))), REAL) by A4
                  .= (s.j) + ((d.(j + 1)) * (b to_power (-j-1)));
  end;

  A5: for k being Nat
  holds d.(k + 1) + r.(k + 1) = b * (r.k) 
  proof
    let k be Nat;
    thus d.(k + 1) + r.(k + 1) = [\ b*(r.k) /] + r.(k + 1) by A3
                              .= [\ b*(r.k) /] + (b*(r.k)-[\ b*(r.k) /]) by A3
                              .= b * (r.k);
  end;

  A6: for n being Nat
  holds s.n + (r.n) * (b to_power -n) = x * (b to_power (-[\ log(b, x) /]))
  proof
    defpred P[Nat] means
    s.$1 + (r.$1) * (b to_power (- $1)) = x * (b to_power (-[\ log(b, x) /]));

    s.0 + (r.0) * (b to_power (- 0))
    = s.0 + (r.0) * 1 by POWER:24
    .= x * (b to_power (-[\ log(b, x) /])) by A1,A2,A4;
    then B1: P[0];

    B2: for k being Nat st P[k] holds P[k + 1]
    proof
      let k be Nat;
      assume B3: P[k];
        
      s.(k + 1) = In(s.k + (d.(k + 1)) * (b to_power (-k - 1)),REAL) by A4; then
      s.(k + 1) + (r.(k + 1)) * (b to_power (- (k + 1)))
      = s.k + (d.(k + 1) + r.(k + 1)) * (b to_power (-k - 1))
      .= s.k + (b * (r.k)) * (b to_power (-k - 1)) by A5
      .= s.k + (r.k) * (b * (b to_power (-k - 1)))
      .= s.k + (r.k) * ((b to_power 1) * (b to_power (-k - 1))) by POWER:25
      .= s.k + (r.k) * (b to_power (-k - 1 + 1)) by POWER:27
      .= s.k + (r.k) * (b to_power -k);
      hence P[k + 1] by B3;
    end;
    
    thus for k being Nat holds P[k] from NAT_1:sch 2(B1, B2);
  end;

  A7: for k being Nat
  holds 0 <= r.k & r.k < 1
  proof
    let k be Nat;
    per cases;
    suppose k=0;
      then r.k = frac (x * (b to_power (-[\ log(b, x) /]))) by A2, INT_1:def 8;
      hence thesis by INT_1:43;
    end;
    suppose k > 0;
      then k >= 0 + 1 by INT_1:7;
      then consider j being Nat such that
      B1: k = 1 + j by NAT_1:10;
      r.k = b*(r.j) - [\ b*(r.j) /] by A3,B1
         .= frac (b*(r.j)) by INT_1:def 8;
      hence thesis by INT_1:43;
    end;
  end;

  A8: for epsilon being Real st 0 < epsilon
  ex N being Nat st
  for m being Nat st N <= m
  holds |.((s.m) - x * (b to_power (-[\ log(b, x) /]))).| < epsilon
  proof
    let epsilon be Real;
    assume B1: 0 < epsilon;
    then consider N being Nat such that
    B2: b to_power -N < epsilon by ThExistenceOfN;
    take N;
    let m be Nat;
    assume B3: N <= m;
    
    B4: |.((s.m) - x * (b to_power (-[\ log(b, x) /]))).| < (b to_power -m)
    proof
      s.m + (r.m)*(b to_power -m) - x * (b to_power (-[\ log(b, x) /]))
      = x*(b to_power (-[\log(b, x)/])) - x*(b to_power (-[\log(b,x)/])) by A6
      .= 0;
      then B5: s.m - x * (b to_power (-[\ log(b, x) /]))
      = - (r.m)*(b to_power -m);
      r.m >= 0 & (b to_power -m) >= 0 by A7; then
      ((r.m)*(b to_power -m)) = |.((r.m)*(b to_power -m)).| by COMPLEX1:43
      .= |.-(r.m) * (b to_power -m).|
      by COMPLEX1:52;
      then B6: |.((s.m) - x * (b to_power (-[\ log(b, x) /]))).| = (r.m)*(b to_power -m)
      by B5;
      0 < (b to_power -m) & r.m < 1 by A7;
      then (r.m)*(b to_power -m) < 1*(b to_power -m) by XREAL_1:68;
      hence |.((s.m) - x * (b to_power (-[\ log(b, x) /]))).| < (b to_power -m)
      by B6;
    end;
    -m <= -N & b > 1 by B3,Def1,XREAL_1:24;
    then b to_power -m <= b to_power -N by Th1;
    then b to_power -m < epsilon by B2, XXREAL_0:2;
    hence |.((s.m) - x * (b to_power (-[\ log(b, x) /]))).| < epsilon
    by B2,B4,XXREAL_0:2;
  end;

  hence s is convergent by SEQ_2:def 6;
  hence lim s = x * (b to_power (-[\ log(b, x) /])) by A8, SEQ_2:def 7;
end;

:: Digits in base b for x*(b to_power (-[\log(b,x)/])), which is x in
:: scientific notation
definition
  let b;
  let x be Real;
  func b-expansion x -> Real_Sequence means :Def2b:
  ex r being Real_Sequence
  st it.0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
  & r.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/]
  & for j being Nat
  holds it.(j+1) = [\ b*(r.j) /]
  & r.(j+1) = b*(r.j) - [\ b*(r.j) /];
  existence by ThBetaExpansionExistence;
  uniqueness
  proof
    let d1 be Real_Sequence;
    let d2 be Real_Sequence;
    assume ex r1 being Real_Sequence
    st d1.0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
    & r1.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/]
    & for j being Nat
    holds d1.(j+1) = [\ b*(r1.j) /]
    & r1.(j+1) = b*(r1.j) - [\ b*(r1.j) /];
    then consider r1 being Real_Sequence such that
    A1: d1.0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
    & r1.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/]
    & for j being Nat
    holds d1.(j+1) = [\ b*(r1.j) /]
    & r1.(j+1) = b*(r1.j) - [\ b*(r1.j) /];
    
    assume ex r2 being Real_Sequence
    st d2.0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
    & r2.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/]
    & for j being Nat
    holds d2.(j+1) = [\ b*(r2.j) /]
    & r2.(j+1) = b*(r2.j) - [\ b*(r2.j) /];
    then consider r2 being Real_Sequence such that
    A2: d2.0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
    & r2.0 = (x*(b to_power (-[\log(b, x)/]))) - [\(x*(b to_power (-[\log(b, x)/])))/]
    & for j being Nat
    holds d2.(j+1) = [\ b*(r2.j) /]
    & r2.(j+1) = b*(r2.j) - [\ b*(r2.j) /];
    
    defpred P[Nat] means d1.$1 = d2.$1 & r1.$1 = r2.$1;
    
    A3: for k being Nat st (for n being Nat st n < k holds P[n]) holds P[k]
    proof
      let k be Nat;
      assume A4: for n being Nat st n < k holds P[n];
      per cases;
      suppose k = 0;
        hence P[k] by A1,A2;
      end;
      suppose k > 0;
        then consider j being Nat such that
        A5: k = j+1 by NAT_1:6;
        j < k by A5, XREAL_1:145;
        then A6: b*(r1.j) = b*(r2.j) by A4;
        then A7: d1.(j+1) = [\b*(r2.j)/] by A1
                         .= d2.(j+1) by A2
                         .= d2.k by A5;
        r1.k = r1.(j + 1) by A5
            .= b*(r1.j) - [\ b*(r1.j) /] by A1
            .= b*(r1.j) - [\ b*(r2.j) /] by A6
            .= b*(r2.j) - [\ b*(r2.j) /] by A6
            .= r2.(j + 1) by A2
            .= r2.k by A5;
        hence P[k] by A5, A7;
      end;
    end;
    for k being Nat holds P[k] from NAT_1:sch 4(A3);
    then for k being Element of NAT holds d1.k = d2.k;
    hence d1 = d2 by FUNCT_2:def 8;
  end;
end;

theorem Th8:
  for x being positive Real
  for n being Nat
  holds 0 <= (b-expansion x).n & (b-expansion x).n < b
  & (b-expansion x).n in NAT
proof
  let x be positive Real;
  let n be Nat;
  set d = b-expansion x;
  consider r being Real_Sequence such that
  A1: d.0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
  & r.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/]
  & for j being Nat
  holds d.(j+1) = [\ b*(r.j) /]
  & r.(j+1) = b*(r.j) - [\ b*(r.j) /]
  by Def2b;
  
  A2: for j being Nat holds 0 <= r.j & r.j < 1
  proof
    let j be Nat;
    per cases;
    suppose j = 0;
      then r.j = frac (x * (b to_power (-[\ log(b, x) /]))) by A1, INT_1:def 8;
      hence thesis by INT_1:43;
    end;
    suppose j > 0;
      then consider k being Nat such that
      B1: j = k + 1 by NAT_1:6;
      r.j = r.(k + 1) by B1
         .= b*(r.k) - [\ b*(r.k) /] by A1
         .= frac (b * (r.k)) by INT_1:def 8;
      hence thesis by INT_1:43;
    end;
  end;
  
  thus 0 <= (b-expansion x).n & (b-expansion x).n < b & (b-expansion x).n in NAT
  proof
    per cases;
    suppose A3: n = 0;
      [\x * (b to_power (-[\ log(b, x) /]))/] <= x * (b to_power (-[\ log(b, x) /]))
      & x * (b to_power (-[\ log(b, x) /])) < b by Th2, INT_1:def 6;
      hence thesis by A1, A3, INT_1:3,54, XXREAL_0:2;
    end;
    suppose n > 0;
      then consider j being Nat such that
      A4: n = j+1 by NAT_1:6;
      b > 1 & 0 <= r.j & r.j < 1 by A2,Def1; then
      A5: 0 <= b*(r.j) & b*(r.j) < b*1 by XREAL_1:68;
      d.(j + 1) = [\b*(r.j)/] by A1;
      then C1: 0 <= d.(j + 1) by A5, INT_1:54;
      [\b*(r.j)/] <= b*(r.j) & b*(r.j) < b by A5, INT_1:def 6;
      then d.(j + 1) <= b*(r.j) & b*(r.j) < b by A1;
      then C2: d.n < b by A4, XXREAL_0:2;
      d.n = [\b*(r.j)/] by A1,A4;
      hence thesis by A4, C1, C2, INT_1:3;
    end;
  end;
end;

theorem ThBetaExpansionHitsZero:
  for x being Real
  for r being Real_Sequence st
  ((b-expansion x).0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
  & r.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/]
  & for j being Nat
  holds (b-expansion x).(j+1) = [\ b*(r.j) /]
  & r.(j+1) = b*(r.j) - [\ b*(r.j) /])
  for j being Nat st r.j = 0
  for k being Nat st k > j
  holds (b-expansion x).k = 0
proof
  let x be Real;
  let r be Real_Sequence;
  assume A1: (b-expansion x).0 = [\ x * (b to_power (-[\ log(b, x) /])) /];
  assume A2: r.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/];
  assume A3: for j being Nat
  holds (b-expansion x).(j+1) = [\ b*(r.j) /]
      & r.(j+1) = b*(r.j) - [\ b*(r.j) /];
  let j be Nat;
  assume A4: r.j = 0;

  defpred P[Nat] means r.(j + $1) = 0;
  A5: for n being Nat st (for m being Nat st m < n holds P[m])
  holds P[n]
  proof
    let n be Nat;
    assume B1: for m being Nat st m < n holds P[m];
    per cases;
    suppose n = 0;
      hence P[n] by A4;
    end;
    suppose n > 0;
      then consider m being Nat such that
      B2: n = m+1 by NAT_1:6;
      m < m + 1 by XREAL_1:145;
      then m < n by B2;
      then P[m] by B1;
      then B3: r.(j + m) = 0;
      r.(j + n) = r.((j + m) + 1) by B2
               .= b*(r.(j + m)) - [\ b*(r.(j + m)) /] by A3
               .= 0 by B3;
      hence P[n];
    end;
  end;

  for n being Nat holds P[n] from NAT_1:sch 4(A5);
  then A6: for n being Nat holds r.(j + n) = 0;
  
  let k be Nat;
  assume k > j;
  then k >= j + 1 by INT_1:7;
  then consider ell being Nat such that
  A7: k = j + 1 + ell by NAT_1:10;
  A8: r.(j + ell) = 0 by A6;
  thus (b-expansion x).k = (b-expansion x).(j + ell + 1) by A7
                        .= [\ b*0 /] by A3, A8
                        .= 0;
end;

theorem ThBetaExpansionOfZero:
  for x being zero Real
  for n being Nat
  holds 0 = (b-expansion x).n
proof
  let x be zero Real;
  let n be Nat;
  set d = b-expansion x;
  consider r being Real_Sequence such that
  A1: d.0 = [\ x * (b to_power (-[\ log(b, x) /])) /]
  & r.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/]
  & for j being Nat
  holds d.(j+1) = [\ b*(r.j) /]
  & r.(j+1) = b*(r.j) - [\ b*(r.j) /] by Def2b;

  per cases;
  suppose n = 0;
    hence (b-expansion x).n = (b-expansion x).0
                           .= [\ 0 * (b to_power (-[\ log(b, x) /])) /] by A1
                           .= 0;
  end;
  suppose A2: n > 0;
    r.0 = (x * (b to_power (-[\ log(b, x) /]))) - [\ (x * (b to_power (-[\ log(b, x) /])))/] by A1
       .= 0 - [\0/]
       .= 0;
    then A3: for j being Nat st j > 0 holds (b-expansion x).j = 0
    by A1, ThBetaExpansionHitsZero;
    hence thesis by A2;
  end;
end;

theorem ThBExpansionOfOne:
  (b-expansion 1).0 = 1
  & for j being Nat st j > 0 holds (b-expansion 1).j = 0
proof
  set d = b-expansion 1;
  consider r being Real_Sequence such that
  A1: d.0 = [\ 1 * (b to_power (-[\ log(b, 1) /])) /]
  & r.0 = (1 * (b to_power (-[\ log(b, 1) /]))) - [\ (1 * (b to_power (-[\ log(b, 1) /])))/]
  & for j being Nat
    holds d.(j+1) = [\ b*(r.j) /]
        & r.(j+1) = b*(r.j) - [\ b*(r.j) /] by Def2b;
  A2: b > 0 & b <> 1 by Def1;
  A3: 1 * (b to_power (-[\ log(b, 1) /])) 
   = b to_power (-[\ 0 /]) by A2, POWER:51 
  .= 1 by POWER:24;
  thus d.0 = 1 by A1, A3;
  let j be Nat;
  assume j > 0;
  hence (b-expansion 1).j = 0 by A1, A3, ThBetaExpansionHitsZero;
end;

theorem ThBExpansionOfPowerOfB:
  for n being Integer
  holds (b-expansion (b to_power n)).0 = 1
  & for j being Nat st j > 0 holds (b-expansion (b to_power n)).j = 0
proof
  let n be Integer;
  set d = b-expansion (b to_power n);
  consider r being Real_Sequence such that
  A1: d.0 = [\ (b to_power n) * (b to_power (-[\log(b,(b to_power n))/]))/]
  & r.0 = ((b to_power n) * (b to_power (-[\ log(b, (b to_power n)) /])))
        - [\ ((b to_power n) * (b to_power (-[\ log(b, (b to_power n)) /])))/]
  & for j being Nat
    holds d.(j+1) = [\ b*(r.j) /]
        & r.(j+1) = b*(r.j) - [\ b*(r.j) /] by Def2b;
  b > 0 & b <> 1 by Def1; then
  A2: (b to_power n) * (b to_power (-[\log(b,b to_power n)/]))
   = (b to_power n) * (b to_power (-[\ n /])) by POWER:def 3
  .= (b to_power n)*(b to_power -n)
  .= b to_power (n + (-n)) by POWER:27
  .= 1 by POWER:24;
  hence (b-expansion (b to_power n)).0 = 1 by A1;
  thus thesis by A1, A2, ThBetaExpansionHitsZero;
end;

theorem Th13:
  for b being Nat st b > 1
  for n being Nat st n <> 0
  holds digits(b |^ n, b).n = 1
  & (for j being Nat st j < n holds digits(b |^ n, b).j = 0)
  & len digits(b |^ n, b) = 1 + n
proof
  let b be Nat;
  assume A1: b > 1;
  let n be Nat;
  assume A2: n <> 0;
  deffunc F(Nat) = IFEQ($1,n,1,0);
  deffunc F1() = n + 1;
  consider d being XFinSequence such that
  A3: len d = F1() & for k being Nat st k in F1() holds d.k = F(k)
  from AFINSQ_1:sch 2;
  for y being object st y in rng d holds y in NAT
  proof
    let y be object;
    assume y in rng d;
    then consider i being object such that
    B1: i in dom d & y = d.i
    by FUNCT_1:def 3;
    reconsider i as Element of NAT by B1;
    per cases;
    suppose B2: i = n;
      y = F(i) by A3,B1
       .= 1 by B2, FUNCOP_1:def 8;
      hence thesis;
    end;
    suppose B3: i <> n;
      y = F(i) by A3,B1
       .= 0 by B3,FUNCOP_1:def 8;
      hence thesis;
    end;
  end;
  then reconsider d as XFinSequence of NAT by TARSKI:def 3, RELAT_1:def 19;

  ex d9 being XFinSequence of NAT
  st (dom d9 = dom d & (for i being Nat st i in dom d9 holds
     d9.i = (d.i) * (b |^ i)) & b |^ n = Sum d9 )
  proof
    deffunc F1() = n + 1;
    deffunc F2(Nat) = (d.$1)*(b |^ $1);
    consider p being XFinSequence such that
    B1: len p = F1() & (for k being Nat st k in F1() holds p.k = F2(k))
    from AFINSQ_1:sch 2;
    for y being object st y in rng p holds y in NAT
    proof
      let y be object;
      assume y in rng p;
      then consider i being object such that
      Z1: i in dom p & y = p.i by FUNCT_1:def 3;
      reconsider i as Element of NAT by Z1;
      y = (d.i) * (b |^ i) by Z1,B1;
      
      hence y in NAT by ORDINAL1:def 12;
    end;
    then reconsider d9=p as XFinSequence of NAT
    by TARSKI:def 3, RELAT_1:def 19;
    take d9;
    
    thus dom d9 = dom d by A3,B1; 
    
    thus (for i being Nat st i in dom d9 holds d9.i = (d.i) * (b |^ i))
    by B1;

    reconsider dd9 = n --> 0 as XFinSequence of NAT by AFINSQ_1:63;
    b |^ n is Element of NAT by ORDINAL1:def 12; then
    reconsider ff9 = <% (b |^ n) %> as XFinSequence of NAT;
    
    len d9 = len (dd9 ^ ff9)
    & for k being Nat st k < len d9 holds d9.k = (dd9 ^ ff9).k
    proof
      thus len (dd9 ^ ff9) = (len dd9) + 1 by AFINSQ_1:75
                          .= len d9 by B1, FUNCOP_1:13;
      let k be Nat;
      assume Z1: k < len d9;
      Z2: len dd9 = n by FUNCOP_1:13;
      per cases;
      suppose Z3: k = n;
        n in Segm (n + 1) by NAT_1:45;
        then Z4: n in (n + 1) by ORDINAL1:def 17;
        thus d9.k = F2(n) by Z1,Z3,B1,AFINSQ_1:86
                 .= F(n)*(b |^ n) by Z4,A3
                 .= 1*(b |^ n) by FUNCOP_1:def 8
                 .= (dd9 ^ ff9).k by Z2,Z3,AFINSQ_1:36;
      end;
      suppose Z5: k <> n;
        then k in Segm n by Z1,B1,NAT_1:22,NAT_1:44;
        then Z6: k in n by ORDINAL1:def 17;
        then LHS: (dd9 ^ ff9).k = dd9.k by Z2, AFINSQ_1:def 3
                               .= 0 by Z6, FUNCOP_1:7;
        k in Segm (n + 1) by B1,Z1,NAT_1:44;
        then Z7: k in n+1 by ORDINAL1:def 17;
        hence d9.k = F2(k) by B1
                  .= IFEQ(k,n,1,0)*(b |^ k) by A3,Z7 
                  .= 0*(b |^ k) by Z5,FUNCOP_1:def 8
                  .= (dd9 ^ ff9).k by LHS;
      end;
    end;
    then d9 = dd9 ^ ff9 by AFINSQ_1:9;
    hence Sum d9 = (Sum dd9) + (Sum ff9) by AFINSQ_2:55
                .= (Sum dd9) + (b |^ n) by AFINSQ_2:53
                .= 0*n + (b |^ n) by AFINSQ_2:58
                .= b |^ n;
  end;
  then A4: value(d,b) = b |^ n by NUMERAL1:def 1;
  A5: b to_power n > 0 by A1;
  d.((len d) - 1) <> 0
  & (for i being Nat st i in dom d holds (0 <= d.i & d.i < b))
  proof
    n < n + 1 by NAT_1:16;
    then n in dom d by A3, AFINSQ_1:86; then
    d.((len d) - 1) = F(n) by A3
                   .= 1 by FUNCOP_1:def 8;
    hence d.((len d) - 1) <> 0;
    let i be Nat;
    assume Z2: i in dom d;
    thus 0 <= d.i;
    per cases;
    suppose i = n;
      then d.i = F(n) by Z2,A3
              .= 1 by FUNCOP_1:def 8;
      hence d.i < b by A1;
    end;
    suppose Z3: i <> n;
      d.i = F(i) by Z2,A3
         .= 0 by Z3, FUNCOP_1:def 8;
      hence d.i < b by A1;
    end;
  end;
  then A6: digits(b |^ n, b) = d & len d = 1 + n
  by A1, A3, A4, A5, NUMERAL1:def 2;

  thus digits(b |^ n, b).n = 1
  proof
    n in Segm (n + 1) by NAT_1:45;
    then n in (n + 1) by ORDINAL1:def 17;
    then d.n = F(n) by A3
            .= 1 by FUNCOP_1:def 8;
    hence thesis by A6;
  end;

  thus for j being Nat st j < n holds digits(b |^ n, b).j = 0
  proof
    let j be Nat;
    assume B1: j < n;
    then j < n + 1 by NAT_1:16, XXREAL_0:2;
    then j in Segm (n + 1) by NAT_1:44;
    then j in (n + 1) by ORDINAL1:def 17;
    hence digits(b |^ n, b).j = F(j) by A3,A6
                             .= 0 by B1, FUNCOP_1:def 8;
  end;

  thus len digits(b |^ n, b) = 1 + n by A6;
end;

definition
  let d be XFinSequence of NAT;
  let b be real Number;
  func beta_integer_value(d,b) -> Real means :Def3a:
  ex d9 being XFinSequence of REAL
  st dom d9 = dom d
  & (for i being Nat st i in dom d9 holds d9.i = (d.i)*(b |^ i))
  & it = Sum d9;
  existence
  proof
    deffunc F(Nat)=(d.$1)*(b |^ $1);
    consider d9 being XFinSequence such that
    A1: len d9 = len d & for i being Nat st i in len d holds d9.i = F(i)
    from AFINSQ_1:sch 2;
    for a being object st a in rng d9 holds a in REAL
    proof
      let a be object;
      assume a in rng d9;
      then consider i being object such that
      A2: i in dom d9 & d9.i = a by FUNCT_1:def 3;
      reconsider i as Element of NAT by A2;
      a=F(i) by A1,A2;
      hence thesis by XREAL_0:def 1;
    end;
    then rng d9 c= REAL by TARSKI:def 3;
    then reconsider d9 as XFinSequence of REAL by RELAT_1:def 19;
    take r=Sum d9;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let k, l be Real;
    given k9 being XFinSequence of REAL such that
    A1: dom k9 = dom d
    & (for i being Nat st i in dom k9 holds k9.i = (d.i)*(b |^ i))
    & k = Sum k9;
    given l9 being XFinSequence of REAL such that
    A2: dom l9 = dom d
    & (for i being Nat st i in dom l9 holds l9.i = (d.i)*(b |^ i))
    & l = Sum l9;
    for i being Nat st i in dom d holds k9.i = l9.i
    proof
      let i be Nat;
      assume i in dom d;
      then A3: i in dom k9 & i in dom l9 by A1,A2;
      hence k9.i = (d.i)*(b |^ i) by A1,A2
                .= l9.i by A1,A2,A3;
    end;
    hence thesis by A1,A2,AFINSQ_1:8;
  end;
end;

definition
  let d be XFinSequence of NAT;
  let b be natural Number;
  redefine func beta_integer_value(d,b) -> Nat means :Def3b:
  ex d9 being XFinSequence of NAT
  st dom d9 = dom d
  & (for i being Nat st i in dom d9 holds d9.i = (d.i)*(b |^ i))
  & it = Sum d9;
  compatibility
  proof
    let a be Nat;
    thus ((a = beta_integer_value(d,b))
    implies (ex d9 being XFinSequence of NAT
    st dom d9 = dom d
    & (for i being Nat st i in dom d9 holds d9.i = (d.i)*(b |^ i))
    & a = Sum d9))
    proof 
      assume a = beta_integer_value(d,b);
      then consider d9 being XFinSequence of REAL such that
      A1: dom d9 = dom d
      & (for i being Nat st i in dom d9 holds d9.i = (d.i)*(b |^ i))
      & a = Sum d9 by Def3a;
      for y being object st y in rng d9 holds y in NAT
      proof
        let y be object;
        assume y in rng d9;
        then consider i being object such that
        A2: i in dom d9 & d9.i = y by FUNCT_1:def 3;
        reconsider i as Element of NAT by A2;
        y = (d.i)*(b |^ i) by A1,A2;
        hence y in NAT by ORDINAL1:def 12;
      end;    
      then rng d9 c= NAT by TARSKI:def 3;
      then reconsider k9=d9 as XFinSequence of NAT by RELAT_1:def 19;
      take k9;
      thus dom k9 = dom d by A1;
      thus (for i being Nat st i in dom k9 holds k9.i = (d.i)*(b |^ i))
      by A1;
      hence thesis by A1,AFINSQ_2:def 9;
    end;
    thus (ex d9 being XFinSequence of NAT
    st dom d9 = dom d
    & (for i being Nat st i in dom d9 holds d9.i = (d.i)*(b |^ i))
    & a = Sum d9) implies (a = beta_integer_value(d,b)) by Def3a;
  end;
  coherence
  proof
    consider d9 being XFinSequence of REAL such that
    A1: dom d9 = dom d
    & (for i being Nat st i in dom d9 holds d9.i = (d.i)*(b |^ i))
    & beta_integer_value(d,b) = Sum d9 by Def3a;
    for y being object st y in rng d9 holds y in NAT
    proof
      let y be object;
      assume y in rng d9;
      then consider i being object such that
      A2: i in dom d9 & d9.i = y by FUNCT_1:def 3;
      reconsider i as Element of NAT by A2;
      y = (d.i)*(b |^ i) by A1,A2;
      hence y in NAT by ORDINAL1:def 12;
    end;    
    then rng d9 c= NAT by TARSKI:def 3;
    then reconsider d9 as XFinSequence of NAT by RELAT_1:def 19;
    d9 is natural-valued;
    hence beta_integer_value(d,b) is Nat by A1, AFINSQ_2:51;
  end;
end;

registration
  let d be XFinSequence of NAT;
  let b be Nat;
  identify beta_integer_value(d,b) with value(d,b);
  compatibility
  proof
    consider d9 being XFinSequence of NAT such that
    A1: dom d9 = dom d
    & (for i being Nat st i in dom d9 holds d9.i = (d.i)*(b |^ i))
    & beta_integer_value(d,b) = Sum d9 by Def3b;
    consider k9 being XFinSequence of NAT such that
    A2: dom k9 = dom d
    & (for i being Nat st i in dom k9 holds k9.i = (d.i)*(b |^ i))
    & value(d,b) = Sum k9 by NUMERAL1:def 1;
    for i being Nat st i in dom d holds k9.i = d9.i
    proof
      let i be Nat;
      assume A3: i in dom d;
      hence k9.i = (d.i)*(b |^ i) by A2
                .= d9.i by A1,A3;
    end;
    hence thesis by A1,A2,AFINSQ_1:8;
  end;
end;

theorem Th15:
  for x being Real
  ex d1 being Real_Sequence
  st (for j being Nat holds d1.j = ((b-expansion x).j)*(b to_power -j))
  & Partial_Sums d1 is convergent
  & lim Partial_Sums d1 = x * (b to_power (-[\ log(b, x) /]))
proof
  let x be Real;
  deffunc F1(Nat) = ((b-expansion x).$1)*(b to_power (- $1));
  consider d1 being Real_Sequence such that
  A1: for n being Nat holds d1.n = F1(n) from SEQ_1:sch 1;
  take d1;
  thus for j being Nat holds d1.j = ((b-expansion x).j)*(b to_power -j)
  by A1;
  
  set d = b-expansion x;
  consider r being Real_Sequence such that
  A2: d.0 = [\ x * (b to_power (-[\log(b,x)/]))/] &
  r.0 = (x * (b to_power (-[\log(b,x)/]))) - [\x * (b to_power (-[\log(b,x)/]))/]
  & for j being Nat holds d.(j + 1) = [\b*(r.j)/]
  & r.(j+1) = b*(r.j) - [\ b*(r.j) /]
  by Def2b;
  
  consider s being Real_Sequence such that
  A3: s.0 = (b-expansion x).0
  & (for j being Nat holds s.(j + 1) = (s.j) + ((d.(j + 1)) * (b to_power (-j-1))))
  & s is convergent
  & lim s = x * (b to_power (-[\ log(b, x) /]))
  by A2, ThBetaExpansionLimit;
  
  set S = (Partial_Sums d1);

  A4: dom S = NAT by SEQ_1:1
           .= dom s by SEQ_1:1;

  defpred P[Nat] means S.$1 = s.$1;
  A5: for n being Nat st (for k being Nat st k < n holds P[k])
  holds P[n]
  proof
    let n be Nat;
    assume B1: for k being Nat st k < n holds P[k];
    per cases;
    suppose B2: n = 0;
      S.0 = d1.0 by SERIES_1:def 1
         .= ((b-expansion x).0) * (b to_power (- 0)) by A1
         .= ((b-expansion x).0) * 1 by POWER:24
         .= s.0 by A3;
      hence thesis by B2;
    end;
    suppose n <> 0;
      then consider m being Nat such that
      B3: n = m + 1 by NAT_1:6;
      B4: m < n by B3, NAT_1:13;
      S.(m + 1) = (S.m) + (d1.(m + 1)) by SERIES_1:def 1
      .= (s.m) + (d1.(m + 1)) by B1,B4
      .= (s.m) + (((b-expansion x).(m + 1)) * (b to_power (- (m + 1)))) by A1
      .= (s.m) + (((b-expansion x).(m + 1)) * (b to_power (- m - 1)))
      .= s.(m + 1) by A3;
      hence P[n] by B3;
    end;
  end;

  for n being Nat holds P[n] from NAT_1:sch 4(A5);
  then for n being object st n in dom S holds S.n = s.n;
  hence thesis by A3, A4, FUNCT_1:2;
end;

theorem Th16:
  for x being Real
  for d1 being Real_Sequence
  st (for j being Nat holds d1.j = ((b-expansion x).j)*(b to_power -j))
  holds Partial_Sums d1 is convergent & d1 is summable
  & lim Partial_Sums d1 = x * (b to_power (-[\ log(b, x) /]))
proof
  let x be Real;
  let d1 be Real_Sequence;
  assume A1: for j being Nat holds d1.j = ((b-expansion x).j)*(b to_power -j);
  consider d being Real_Sequence such that
  A2: (for j being Nat holds d.j = ((b-expansion x).j)*(b to_power -j)) and
  A3: Partial_Sums d is convergent
  & lim Partial_Sums d = x * (b to_power (-[\ log(b, x) /])) by Th15;
 
  for j being Element of NAT holds d.j = d1.j
  proof
    let j be Element of NAT;
    thus d.j = ((b-expansion x).j)*(b to_power -j) by A2
            .= d1.j by A1;
  end;
  then d = d1 by FUNCT_2:def 8;
  hence thesis by A3, SERIES_1:def 2;
end;

theorem Th17:
  for x being positive Real
  for n being Nat
  for d1 being Real_Sequence
  st (for j being Nat holds d1.j = ((b-expansion x).j)*(b to_power -j))
  holds (Partial_Sums d1).n <= x * (b to_power (-[\ log(b, x) /]))
  & x * (b to_power (-[\ log(b, x) /])) <= ((([/b\] - 1)/(b - 1))*(b to_power -n)) + (Partial_Sums d1).n
proof
  let x be positive Real;
  let n be Nat;
  let d1 be Real_Sequence;
  assume A1: for j being Nat holds d1.j = ((b-expansion x).j)*(b to_power -j);
  A2: for j being Nat holds 0 <= d1.j & d1.j < b to_power (1 - j)
  proof
    let j be Nat;
    (b-expansion x).j >= 0 by Th8;
    then ((b-expansion x).j)*(b to_power -j) >= 0;
    hence 0 <= d1.j by A1;

    B1: ((b-expansion x).j)*(b to_power -j) < b*(b to_power -j)
    by Th8, XREAL_1:68;
    b*(b to_power -j) = (b to_power 1)*(b to_power -j)
                     .= b to_power (1 + (-j)) by POWER:27
                     .= b to_power (1 - j);
    hence d1.j < b to_power (1 - j) by A1, B1;
  end;
  A3: Partial_Sums d1 is convergent & d1 is summable
  & lim Partial_Sums d1 = x * (b to_power (-[\ log(b, x) /])) by A1, Th16;

  A4: 0 <= (Sum (d1 ^\ (n + 1)))
  proof
    B1: (d1 ^\ (n + 1)) is summable by A3, SERIES_1:12;
    for j being Nat holds 0 <= (d1 ^\ (n + 1)).j
    proof
      let j be Nat;
      (d1 ^\ (n + 1)).j = d1.((n + 1) + j) by NAT_1:def 3;
      hence 0 <= (d1 ^\ (n + 1)).j by A2;
    end;
    hence thesis by B1, SERIES_1:18;
  end;
  set alpha = x * (b to_power (-[\ log(b, x) /]));
  set remainder = (Sum (d1 ^\ (n + 1)));
  alpha = Sum d1 by A3, SERIES_1:def 3
       .= ((Partial_Sums d1).n) + (Sum (d1 ^\ (n + 1))) by A3,SERIES_1:15;
  then (((Partial_Sums d1).n) + remainder) - remainder <= alpha
  by A4,XREAL_1:43;
  hence (Partial_Sums d1).n <= x * (b to_power (-[\ log(b, x) /]));
  set k0 = ([/b\] - 1)*(b to_power (- n -1));

  A5: (b" GeoSeq) is summable & (k0 (#) (b" GeoSeq)) is summable
  & Sum (b" GeoSeq) = 1/(1 - (b "))
  proof
    0 < b" & b" < 1" by Def1, XREAL_1:88;
    then |. b" .| < 1 by COMPLEX1:43;
    then (b" GeoSeq) is summable & Sum (b" GeoSeq) = 1/(1 - (b "))
    by SERIES_1:24;
    hence thesis by SERIES_1:10;
  end;
  for j being Nat
  holds 0 <= (d1 ^\ (n + 1)).j
  & (d1 ^\ (n + 1)).j <= (k0 (#) ((b") GeoSeq)).j
  proof
    let j be Nat;
    B1: (d1 ^\ (n + 1)).j = d1.((n + 1) + j) by NAT_1:def 3;
    hence 0 <= (d1 ^\ (n + 1)).j by A2;
    
    B2: for i being Nat
    holds d1.i <= ([/b\] - 1)*(b to_power -i)
    proof
      let i be Nat;
      (b-expansion x).i in NAT by Th8;
      then reconsider bxi=(b-expansion x).i as Nat;
      b <= [/b\] by INT_1:30,31;
      then bxi < [/b\] by Th8, XXREAL_0:2;
      then (b-expansion x).i <= [/b\] - 1 by INT_1:52;
      then ((b-expansion x).i)*(b to_power -i) <= ([/b\] - 1)*(b to_power -i)
      by XREAL_1:64;
      hence d1.i <= ([/b\] - 1)*(b to_power -i) by A1;
    end;
    
    (b to_power -((n + 1) + j))
    = b to_power ((-(n + 1)) + (-j))
    .= (b to_power (-n -1)) * (b to_power -j) by POWER:27;
    then B3: ([/b\] - 1)*(b to_power -((n + 1) + j))
    = k0 * (b to_power -j)
    .= k0 * ((1 / b) to_power j) by POWER:32
    .= k0 * ((b ") to_power j) by XCMPLX_1:215
    .= k0 * (((b ") GeoSeq).j) by PREPOWER:def 1;
    (d1 ^\ (n + 1)).j <= ([/b\] - 1)*(b to_power -((n + 1) + j)) by B1,B2;
    then (d1 ^\ (n + 1)).j <= k0 * (((b ") GeoSeq).j) by B3;
    hence thesis by VALUED_1:6;
  end;
  then A6: Sum (d1 ^\ (n + 1)) <= Sum (k0 (#) ((b") GeoSeq))
  by A5, SERIES_1:20;
  A7: (Partial_Sums d1).n + Sum (d1 ^\ (n + 1)) = Sum d1 by A3, SERIES_1:15
  .= x * (b to_power (-[\log(b,x)/])) by A3, SERIES_1:def 3;
  Sum (k0 (#) ((b ") GeoSeq)) = (([/b\] - 1)/(b - 1))*(b to_power -n)
  proof
    (([/b\] - 1)*(b to_power (- n -1))) * (1 / (1 - (b ")))
     = (b to_power (- n -1)) * (([/b\] - 1) * (1 / (1 - (b "))))
    .= (b to_power (- n -1)) * ((([/b\] - 1) * 1)/(1 - (b "))) by XCMPLX_1:74
    .= ((b to_power -n)/(b to_power 1)) * (([/b\] - 1)/(1 - (b "))) by POWER:29
    .= ((b to_power -n) * ([/b\] - 1)) / (b *(1 - (b " ))) by XCMPLX_1:76 
    .= ((b to_power -n) * ([/b\] - 1)) / (b - (b * (b ")))
    .= ((b to_power -n) * ([/b\] - 1)) / (b - 1) by XCMPLX_0:def 7
    .= (([/b\] - 1)/(b - 1))*(b to_power -n) by XCMPLX_1:74;
    hence thesis by A5, SERIES_1:10;
  end;
  then Sum (k0 (#) ((b") GeoSeq)) <= (([/b\] - 1)/(b - 1))*(b to_power -n);
  then Sum (d1 ^\ (n + 1)) <= (([/b\] - 1)/(b - 1))*(b to_power -n)
  by A6, XXREAL_0:2;
  then (Partial_Sums d1).n + Sum (d1 ^\ (n + 1))
  <= (Partial_Sums d1).n + (([/b\] - 1)/(b - 1))*(b to_power -n) by XREAL_1:6;
  hence thesis by A7;
end;

definition
  let b be Real;
  func b-radix_NAT -> Subset of REAL equals :Def5:
  { x where x is Element of REAL : x = 0 or ex d being XFinSequence of NAT
    st d.((len d)-1) <> 0
    & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
    & x = beta_integer_value(d,b) };
  coherence
  proof
    set IT = { x where x is Element of REAL : x = 0 or
    ex d being XFinSequence of NAT
    st d.((len d)-1) <> 0
    & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
    & x = beta_integer_value(d,b) };
    for r being object st r in IT holds r in REAL
    proof
      let r be object;
      assume r in IT;
      then consider x being Element of REAL such that
      A1: x=r & (x = 0 or
      ex d being XFinSequence of NAT
      st d.((len d)-1) <> 0
      & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
      & x = beta_integer_value(d,b));
      thus thesis by A1;
    end;
    hence thesis by TARSKI:def 3;
  end;
end;

theorem ThBetaNATCriterion:
  for b,x being Real st x <> 0
  holds x in b-radix_NAT iff ex d being XFinSequence of NAT
    st d.((len d)-1) <> 0
    & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
    & x = beta_integer_value(d,b)
proof
  let b,x be Real;
  assume A1: x <> 0;
  thus x in b-radix_NAT implies ex d being XFinSequence of NAT
    st d.((len d)-1) <> 0
    & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
    & x = beta_integer_value(d,b)
  proof
    assume x in b-radix_NAT;
    then ex r being Element of REAL st r=x & (r = 0 or
    ex d being XFinSequence of NAT
    st d.((len d)-1) <> 0
    & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
    & r = beta_integer_value(d,b));
    hence thesis by A1;
  end;
  given d being XFinSequence of NAT such that
  A2: d.((len d)-1) <> 0
    & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
    & x = beta_integer_value(d,b);
  ex r being Element of REAL st r=x & (r = 0 or
  ex d1 being XFinSequence of NAT
  st d1.((len d1)-1) <> 0
  & (for j being Nat st j in dom d1 holds 0 <= d1.j & d1.j < b)
  & r = beta_integer_value(d1,b))
  proof
    reconsider r=x as Element of REAL by XREAL_0:def 1;
    take r;
    thus thesis by A2;
  end;
  hence x in b-radix_NAT;
end;

theorem ThZeroInBetaNAT:
  for beta being Real holds 0 in beta-radix_NAT
proof
  let beta be Real;
  0 is Element of REAL by XREAL_0:def 1;
  hence thesis;
end;

registration
  let beta be Real;
  cluster beta-radix_NAT -> non empty;
  correctness by ThZeroInBetaNAT;
  cluster non negative for Element of beta-radix_NAT;
  existence
  proof
    reconsider x=0 as Element of beta-radix_NAT by ThZeroInBetaNAT;
    take x;
    thus thesis;
  end;
  cluster zero for Element of beta-radix_NAT;
  existence
  proof
    reconsider x=0 as Element of beta-radix_NAT by ThZeroInBetaNAT;
    take x;
    thus thesis;
  end;
end;

theorem ThBetaRadixNatCompatibility:
  for b being Nat st b > 1 holds b-radix_NAT = NAT
proof
  let b be Nat;
  assume A1: b > 1;
  for y being object st y in b-radix_NAT holds y in NAT
  proof
    let y be object;
    assume y in b-radix_NAT;
    then consider x being Element of REAL such that
    B1: y = x and
    B2: x = 0 or (ex d being XFinSequence of NAT
    st d.((len d)-1) <> 0
    & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
    & x = beta_integer_value(d,b));
    per cases by B2;
    suppose x = 0;
      hence thesis by B1;
    end;
    suppose ex d being XFinSequence of NAT
      st d.((len d)-1) <> 0
      & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
      & x = beta_integer_value(d,b);
      then consider d being XFinSequence of NAT such that
      B3: d.((len d)-1) <> 0
      & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
      & x = beta_integer_value(d,b);
      thus y in NAT by B1, B3, ORDINAL1:def 12;
    end;
  end;

  then A2: b-radix_NAT c= NAT by TARSKI:def 3;
  for x being object st x in NAT holds x in b-radix_NAT
  proof
    let x be object;
    assume B1: x in NAT;
    then reconsider n=x as Nat;
    per cases;
    suppose n = 0;
      hence thesis by ThZeroInBetaNAT;
    end;
    suppose B2: n <> 0;
      ex d being XFinSequence of NAT
      st d.((len d)-1) <> 0
      & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
      & n = beta_integer_value(d,b)
      proof
        take d = digits(n,b);
        thus thesis by A1, B2, NUMERAL1:def 2;
      end;
      hence x in b-radix_NAT by B2,ThBetaNATCriterion;
    end;
  end;
  then NAT c= b-radix_NAT by TARSKI:def 3;
  hence b-radix_NAT = NAT by A2, XBOOLE_0:def 10;
end;

theorem ThBetaRadixNATAreNonNegative:
  for beta being positive Real
  for x being Element of beta-radix_NAT
  holds x >= 0
proof
  let beta be positive Real;
  let x be Element of beta-radix_NAT;
  per cases;
  suppose x = 0;
    hence thesis by XXREAL_0:1;
  end;
  suppose x <> 0;
    then consider d being XFinSequence of NAT such that
    A1: d.((len d) - 1) <> 0
    & (for j being Nat st j in dom d holds 0 <= d.j & d.j < beta)
    & x = beta_integer_value(d,beta) by ThBetaNATCriterion;
    consider d9 being XFinSequence of REAL such that
    A2: dom d9 = dom d
    & (for j being Nat st j in dom d9 holds d9.j = (d.j)*(beta |^ j))
    & beta_integer_value(d,beta) = Sum d9
    by A1, Def3a;
    for j being Nat st j in dom d9 holds d9.j >= 0
    proof
      let j be Nat;
      assume A3: j in dom d9;
      beta > 0;
      then beta to_power j > 0 by POWER:34;
      then A4: beta |^ j > 0 by POWER:41;
      d.j >= 0 by A1,A2,A3;
      then (d.j) * (beta |^ j) >= 0 by A4, XREAL_1:127;
      hence thesis by A2,A3;
    end;
    then Sum d9 >= (len d9)*0 by AFINSQ_2:60;
    hence x >= 0 by A1,A2;
  end;
end;

registration
  let beta be positive Real;
  cluster -> non negative for Element of beta-radix_NAT;
  correctness by ThBetaRadixNATAreNonNegative;
end;

theorem ThSmallestPositiveBetaRadixNat:
  for n being Element of b-radix_NAT
  st 0 < n
  holds 1 <= n
proof
  let n be Element of b-radix_NAT;
  assume A1: 0 < n;
  then consider d being XFinSequence of NAT such that
  A2: d.((len d)-1) <> 0
  & (for j being Nat st j in dom d holds 0 <= d.j & d.j < b)
  & n = beta_integer_value(d,b)
  by ThBetaNATCriterion;
  consider d9 being XFinSequence of REAL such that
  A3: dom d9 = dom d
  & (for i being Nat st i in dom d9 holds d9.i = (d.i)*(b |^ i))
  & beta_integer_value(d,b) = Sum d9
  by Def3a;

  set y = (d.((len d) - 1)) * (b to_power ((len d) - 1));
  for r being Real st r in rng d9 holds 0 <= r
  proof
    let r be Real;
    assume r in rng d9;
    then consider i being object such that
    B1: i in dom d9 & d9.i = r by FUNCT_1:def 3;
    reconsider i as Element of NAT by B1;
    r = (d.i)*(b to_power i) by A3, B1;
    hence 0 <= r;
  end;
  then A5: d9 is nonnegative-yielding by PARTFUN3:def 4;
  then len d9 = 0 implies contradiction by A1, A2, A3, AFINSQ_2:62;
  then len d9 > 0;
  then 0 + len d9 > 0;
  then A6: len d9 >= 1 by NAT_1:19;
  ex x being object st (x in dom d9 & d9.x = y)
  proof
    1 <= len d by A3,A6;
    then (len d) - 1 in NAT by INT_1:5;
    then reconsider x=(len d) - 1 as Nat;
    take x;
    (len d) - 1 < (len d) - 0 by XREAL_1:15;
    then (len d) - 1 < (len d);
    then x < len d;
    then x < len d9 by A3;
    hence x in dom d9 by AFINSQ_1:86;
    hence d9.x = (d.x) * (b to_power x) by A3
              .= y;
  end;
  then Sum d9 >= y by A5, A6, AFINSQ_2:61;
  then A7: n >= y by A2,A3;
  y >= 1
  proof
    d.((len d) - 1) <> 0 by A2;
    then d.((len d) - 1) > 0;
    then d.((len d) - 1) >= 0 + 1 by INT_1:7;
    then B1: d.((len d) - 1) >= 1;
    (len d) >= 1 by A3,A6;
    then (len d) = 1 or (len d) > 1 by NAT_1:25;
    then per cases;
    suppose len d = 1;
      then (len d) + (- 1) = 0;
      then (b to_power ((len d) - 1)) = 1 by POWER:24;
      hence thesis by B1;
    end;
    suppose len d > 1;
      then (len d) - 1 > 0 by XREAL_1:50;
      then (b to_power ((len d) - 1)) > 1 by Def1, POWER:35;
      then 1 <= (b to_power ((len d) - 1)) & 1 <= d.((len d) -1) by B1;
      then 1 * 1 <= (d.((len d) - 1)) * (b to_power ((len d) - 1)) by XREAL_1:66;
      hence thesis;
    end;
  end;
  hence n >= 1 by A7, XXREAL_0:2;
end;

LmShiftIndex:
  for i being Nat
  for d being XFinSequence
  for x being object
  st i in dom d
  holds (<%x%> ^ d).(i + 1) = d.i
proof
  let i be Nat;
  let d be XFinSequence;
  let x be object;
  assume A1: i in dom d;
  A2: 1 = len <%x%> by AFINSQ_1:def 4;
  len (<%x%>) <= i + 1 & i + 1 < len (<%x%> ^ d)
  proof
    thus len (<%x%>) <= i + 1 by A2, XREAL_1:38;
    i + 1 < 1 + (len d) by A1, AFINSQ_1:86, XREAL_1:6;
    hence i + 1 < len (<%x%> ^ d) by A2, AFINSQ_1:17;
  end;
  hence (<%x%> ^ d).(i + 1) = d.((i + 1) -1) by A2, AFINSQ_1:19
                           .= d.i;
end;

theorem LmLeftShiftOnceBetaRadixNAT:
  for beta being positive Real
  for m being Element of beta-radix_NAT
  holds beta*m in beta-radix_NAT
proof
  let beta be positive Real;
  let m be Element of beta-radix_NAT;
  per cases;
  suppose A1: m = 0;
    then beta*m = m;
    hence thesis;
  end;
  suppose A2: m <> 0;
    then consider d being XFinSequence of NAT such that
    A3: d.((len d) - 1) <> 0
    & (for j being Nat st j in dom d holds 0 <= d.j & d.j < beta)
    & m = beta_integer_value(d,beta)
    by ThBetaNATCriterion;
    set d1 = <%0%> ^ d;
    A4: len <%0%> = 1 by AFINSQ_1:def 4;
    A5: d1.((len d1) - 1) <> 0
    proof
      (len d) - 1 in dom d by A3, FUNCT_1:def 2;
      then d.((len d) - 1) = d1.((len <%0%>) + ((len d) - 1)) by AFINSQ_1:def 3
                          .= d1.((1 + (len d)) - 1) by A4
                          .= d1.((len d1) - 1) by A4, AFINSQ_1:def 3;
      hence thesis by A3;
    end;
    A6: for j being Nat st j in dom d1 holds 0 <= d1.j & d1.j < beta
    proof
      let j be Nat;
      assume B1: j in dom d1;
      per cases;
      suppose j = 0;
        hence thesis by AFINSQ_1:35;
      end;
      suppose j <> 0;
        then consider k being Nat such that
        B2: j = k + 1 by NAT_1:6;
        k + 1 < len d1 by B1, B2, AFINSQ_1:86;
        then k + 1 < (len <%0%>) + (len d) by AFINSQ_1:17;
        then (k + 1) -1 < (1 + len d) -1 by A4, XREAL_1:9;
        then B3: k in dom d by AFINSQ_1:86;
        then B4: 1 + k < (len <%0%>) + (len d)
        by A4, AFINSQ_1:86, XREAL_1:8;
        j = k + len <%0%> by B2, AFINSQ_1:def 4;
        then d1.j = d.(j - 1) by B2, B4, NAT_1:11, AFINSQ_1:18
                 .= d.k by B2;
        hence thesis by A3, B3;
      end;
    end;
    beta * m = beta_integer_value(d1,beta)
    proof
      consider d9 being XFinSequence of REAL such that
      B1: dom d9 = dom d
      & (for i being Nat st i in dom d9 holds d9.i = (d.i)*(beta |^ i))
      & beta_integer_value(d, beta) = Sum d9
      by Def3a;
      consider d91 being XFinSequence of REAL such that
      B2: dom d91 = dom d1
      & (for i being Nat st i in dom d91 holds d91.i = (d1.i)*(beta |^ i))
      & beta_integer_value(d1,beta) = Sum d91
      by Def3a;
      d91 = <%0%> ^ (d91 /^ 1)
      proof
        0 < 1 + len d;
        then 0 < len (<%0%> ^ d) by A4, AFINSQ_1:17;
        then Z1: 0 in dom d91 by B2, AFINSQ_1:66;
        then Z2: dom (d91) /\ 1 = 1 & dom (<% d91.0 %>) = 1
        by CARD_1:49, AFINSQ_1:def 4, ZFMISC_1:46;
        for i being object st i in dom (d91) /\ 1 holds d91.i = <% d91.0 %>.i
        proof
          let i be object;
          assume i in dom (d91) /\ 1;
          then i = 0 by Z2, CARD_1:49, TARSKI:def 1;
          hence thesis;
        end;
        then Z3: d91 | 1 = <% d91.0 %> by Z2, FUNCT_1:46;
        d91.0 = (d1.0)*(beta |^ 0) by B2,Z1
             .= 0 *(beta |^ 0) by AFINSQ_1:35
             .= 0;
        hence thesis by Z3;
      end;
      then
      B3: Sum d91 = (Sum <%0%>) + Sum (d91 /^ 1) by AFINSQ_2:55
                 .= 0 + Sum (d91 /^ 1) by AFINSQ_2:53;
      B4: 1 < len d91 & len d91 = 1 + len d
      proof
        for r being Real st r in rng d9 holds 0 <= r
        proof
          let r be Real;
          assume r in rng d9;
          then consider i being object such that
          Z1: i in dom d9 & d9.i = r by FUNCT_1:def 3;
          reconsider i as Nat by Z1;
          r = (d.i)*(beta to_power i) by B1, Z1;
          hence 0 <= r;
        end;
        then d9 is nonnegative-yielding by PARTFUN3:def 4;
        then Sum d9 = 0 iff (len d9 = 0 or d9 = (len d9) --> 0)
        by AFINSQ_2:62;
        then C1: 1 + len d > 1 + 0 by A2, A3, B1, XREAL_1:8;
        len d91 = len (<%0%>) + len d by B2, AFINSQ_1:17
               .= 1 + len d by AFINSQ_1:def 4;
        hence thesis by C1;
      end;
      then
      B5: len (d91 /^ 1) = (len d91) - 1 by AFINSQ_2:7
                        .= ((len <%0%>) + (len d)) - 1 by B2, AFINSQ_1:17
                        .= (1 + (len d)) - 1 by AFINSQ_1:def 4
                        .= len (beta (#) d9) by B1, VALUED_1:def 5;
      for i being Nat
      st i < len (d91 /^ 1)
      holds (d91 /^ 1).i = (beta (#) d9).i
      proof
        let i be Nat;
        assume Z1: i < len (d91 /^ 1);
        dom (beta (#) d9) = dom d9 by VALUED_1:def 5;
        then Z2: i in dom (d91 /^ 1) & i in dom (beta (#) d9)
        & i in dom d9
        by B5,Z1,AFINSQ_1:86;
        len (d91 /^ 1) = (len d91) -' 1 by AFINSQ_2:def 2
                      .= (len d91) - 1 by B4, XREAL_0:def 2;
        then Z3: i + 1 in dom d91 by Z1, XREAL_1:20, AFINSQ_1:86;
        then Z4: d1.(i + 1) = d.i by B1, Z2, LmShiftIndex;
        (d91 /^ 1).i = d91.(i + 1) by Z2, AFINSQ_2:def 2
                    .= (d1.(i + 1)) * (beta to_power (i + 1)) by B2,Z3
                    .= (d.i) * ((beta to_power i) * (beta to_power 1))
                       by Z4, POWER:27
                    .= beta * ((d.i) * (beta to_power i))
                    .= beta * (d9.i) by Z2, B1
                    .= (beta (#) d9).i by VALUED_1:6;
        hence (d91 /^ 1).i = (beta (#) d9).i;
      end;
      then Sum (d91 /^ 1) = Sum (beta (#) d9) by B5, AFINSQ_1:9
                         .= beta * m by A3, B1, AFINSQ_2:64;
      hence thesis by B2,B3;
    end;
    hence beta*m in beta-radix_NAT by A2,A5,A6,ThBetaNATCriterion;
  end;
end;

theorem ThLeftShiftBetaRadixNAT:
  for beta being positive Real
  for m being Element of beta-radix_NAT
  for N being Integer st N in NAT
  holds m*(beta to_power N) in beta-radix_NAT
proof
  let beta be positive Real;
  let m be Element of beta-radix_NAT;
  let N be Integer;
  assume A1: N in NAT;
  then reconsider N1=N as Nat;
  defpred P[Nat] means m*(beta to_power $1) in beta-radix_NAT;
  A2: for n being Nat st (for k being Nat st k < n holds P[k])
  holds P[n]
  proof
    let n be Nat;
    assume B1: for k being Nat st k < n holds P[k];
    per cases;
    suppose n = 0;
      then m*(beta to_power n) = m * 1 by POWER:24;
      hence thesis;
    end;
    suppose n <> 0;
      then consider k being Nat such that
      B2: n = k + 1 by NAT_1:6;
      k < n by B2, NAT_1:16;
      then B3: m * (beta to_power k) in beta-radix_NAT by B1;
      m * (beta to_power n) 
       = m * ((beta to_power k) * (beta to_power 1)) by B2, POWER:27
      .= beta * (m * (beta to_power k));
      hence P[n] by B3, LmLeftShiftOnceBetaRadixNAT;
    end;
  end;
  for k being Nat holds P[k] from NAT_1:sch 4(A2);
  then P[N1];
  hence thesis;
end;

definition
  let beta be Real;
  func beta-radix_INT -> Subset of REAL means :Def6:
  for x being Real
  holds x in it iff x in beta-radix_NAT or -x in beta-radix_NAT;
  existence
  proof
    set IT = {x where x is Element of REAL : x in beta-radix_NAT or -x in beta-radix_NAT };
    
    for y being object st y in IT holds y in REAL
    proof
      let y be object;
      assume y in IT;
      then ex x being Element of REAL st x=y & (x in beta-radix_NAT or -x in beta-radix_NAT);
      hence y in REAL;
    end;
    then reconsider IT as Subset of REAL by TARSKI:def 3;
    take IT;
    for x being Real holds x in IT iff (x in beta-radix_NAT or -x in beta-radix_NAT)
    proof
      let x be Real;
      thus x in IT implies (x in beta-radix_NAT or -x in beta-radix_NAT)
      proof 
        assume x in IT;
        then ex y being Element of REAL st y=x & (y in beta-radix_NAT
        or -y in beta-radix_NAT);
        hence thesis;
      end;
      assume (x in beta-radix_NAT or -x in beta-radix_NAT);
      then x in REAL & (x in beta-radix_NAT or -x in beta-radix_NAT) by XREAL_0:def 1;
      hence x in IT;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    defpred P[Real] means ($1 in beta-radix_NAT or -$1 in beta-radix_NAT);
    let X,Y be Subset of REAL such that
    A1: for x being Real holds x in X iff P[x] and
    A2: for x being Real holds x in Y iff P[x];
    for x being Element of REAL holds x in X iff x in Y
    proof
      let x be Element of REAL;
      hereby 
        assume x in X;
        then P[x] by A1;
        hence x in Y by A2;
      end;
      assume x in Y;
      then P[x] by A2;
      hence x in X by A1;
    end;
    hence X = Y by SUBSET_1:3;
  end;
end;

theorem Th20:
  for beta being Real
  holds beta-radix_NAT c= beta-radix_INT
proof
  let beta be Real;
  for x being Element of REAL st x in beta-radix_NAT
  holds x in beta-radix_INT by Def6;
  hence beta-radix_NAT c= beta-radix_INT by SUBSET_1:2;
end;

theorem ThZeroInBetaINT:
  for beta being Real holds 0 in beta-radix_INT
proof
  let beta be Real;
  0 in beta-radix_NAT by ThZeroInBetaNAT;
  hence thesis by Def6, COMPLEX1:44;
end;

registration
  let beta be Real;
  cluster beta-radix_INT -> non empty;
  coherence by ThZeroInBetaINT;
  cluster zero for Element of beta-radix_INT;
  existence
  proof
    reconsider x=0 as Element of beta-radix_INT by ThZeroInBetaINT;
    take x;
    thus thesis;
  end;
end;

theorem Th24:
  for beta being Real
  for x being Real
  holds x in beta-radix_INT
    iff ex k being Element of beta-radix_NAT st x=k or x=-k
proof
  let beta be Real;
  let x be Real;
  
  thus x in beta-radix_INT
  implies ex k being Element of beta-radix_NAT st x=k or x=-k
  proof
    assume x in beta-radix_INT;
    then x in beta-radix_NAT or -x in beta-radix_NAT by Def6;
    then consider k being Element of beta-radix_NAT such that
    A1: x=k or -x=k;
    take k;
    thus x=k or x = -k by A1;
  end;
  
  thus (ex k being Element of beta-radix_NAT st x=k or x=-k)
  implies x in beta-radix_INT
  proof
    given k being Element of beta-radix_NAT such that 
    A2: x=k or x=-k;
    x in beta-radix_NAT or -x in beta-radix_NAT by A2;
    hence x in beta-radix_INT by Def6;
  end;
end;

theorem ThBRadixINTCompatibility:
  for b being Nat st b > 1
  holds b-radix_INT = INT
proof
  let b be Nat;
  assume A1: b > 1;
  then A2: b-radix_NAT = NAT by ThBetaRadixNatCompatibility;
  for x being object st x in b-radix_INT holds x in INT
  proof
    let x be object;
    assume B1: x in b-radix_INT;
    then reconsider y=x as Element of REAL;
    y in NAT or -y in NAT by A2, B1, Def6;
    then consider k being Nat such that
    B2: y=k or -y=k;
    y = k or y = -k by B2;
    hence thesis by INT_1:def 1;
  end;
  then A3: b-radix_INT c= INT by TARSKI:def 3;

  for x being object st x in INT holds x in b-radix_INT
  proof
    let x be object;
    assume B1: x in INT;
    then reconsider y=x as Integer;
    ex k being Nat st y = k or y = -k by B1, INT_1:def 1;
    then consider k being Nat such that
    B2: k = y or k = - y;
    reconsider ell=k as Element of b-radix_NAT by A2, ORDINAL1:def 12;
    y = ell or y = -ell by B2;
    hence x in b-radix_INT by Th24;
  end;
  then INT c= b-radix_INT by TARSKI:def 3;
  hence b-radix_INT = INT by A3, XBOOLE_0:def 10;
end;

theorem ThPositiveBetaRadixIntAreBetaRadixNat:
  for n being Element of b-radix_INT
  st 0 <= n
  holds n in b-radix_NAT
proof
  let n be Element of b-radix_INT;
  assume A1: 0 <= n;
  then per cases;
  suppose 0 = n;
    hence thesis;
  end;
  suppose A2: n > 0;
    consider k being Element of b-radix_NAT such that
    A3: n = k or n = -k by Th24;
    thus thesis by A2,A3;
  end;
end;

theorem ThSmallestPositiveBetaRadixInt:
  for n being Element of b-radix_INT
  st 0 < n
  holds 1 <= n
proof
  let n be Element of b-radix_INT;
  assume A1: 0 < n;
  then n in b-radix_NAT by ThPositiveBetaRadixIntAreBetaRadixNat;
  hence 1 <= n by A1, ThSmallestPositiveBetaRadixNat;
end;

theorem ThBetaRadixIntClosedUnderNegation:
  for beta being positive Real
  for x being Element of beta-radix_INT
  holds -x in beta-radix_INT
proof
  let beta be positive Real;
  let x be Element of beta-radix_INT;
  ex k being Element of beta-radix_NAT st x = k or x = -k by Th24;
  hence -x in beta-radix_INT by Th24;
end;

theorem ThLeftShiftBetaRadixINT:
  for beta being positive Real
  for m being Element of beta-radix_INT
  for N being Integer st N in NAT
  holds m*(beta to_power N) in beta-radix_INT
proof
  let beta be positive Real;
  let m be Element of beta-radix_INT;
  let N be Integer;
  assume A1: N in NAT;
  consider k being Element of beta-radix_NAT such that
  A2: m=k or m=-k by Th24;
  per cases by A2;
  suppose m=k;
    then m*(beta to_power N)=k*(beta to_power N)
    & k*(beta to_power N) in beta-radix_NAT by A1, ThLeftShiftBetaRadixNAT;
    hence thesis by Th20, TARSKI:def 3;
  end;
  suppose m=-k;
    then m*(beta to_power N)=-(k*(beta to_power N))
    & k*(beta to_power N) in beta-radix_NAT by A1, ThLeftShiftBetaRadixNAT;
    hence thesis by Th24;
  end;
end;

::: Extended Integers

definition
  func ExtINT -> Subset of ExtREAL equals
  INT \/ {-infty,+infty};
  coherence
  proof
    INT c= REAL & REAL c= ExtREAL by XBOOLE_0:def 8, NUMBERS:5,31; then
    A1: INT c= ExtREAL by XBOOLE_1:1;
    {-infty,+infty} c= ExtREAL by XBOOLE_1:7, XXREAL_0:def 4;
    hence thesis by A1, XBOOLE_1:8;
  end;
end;

theorem Th2:
  INT c< ExtINT & ExtNAT c< ExtINT & ExtINT c< ExtREAL
proof
  thus INT c< ExtINT
  proof
    +infty in {+infty,-infty} by TARSKI:def 2; then
    A1: +infty in ExtINT by XBOOLE_0:def 3;
    not +infty in INT;
    hence thesis by A1, XBOOLE_0:def 8, XBOOLE_1:7;
  end;
  thus ExtNAT c< ExtINT
  proof
    -1 in INT & not -1 in NAT & not -1 in {+infty} by INT_1:def 1;
    then A2: -1 in ExtINT & not -1 in ExtNAT by XBOOLE_0:def 3;
    NAT c= INT & {+infty} c= {-infty,+infty} by NUMBERS:17, ZFMISC_1:7;
    hence thesis by A2, COUNTERS:def 1, XBOOLE_1:13, XBOOLE_0:def 8;
  end;
  thus ExtINT c< ExtREAL
  proof
    not REAL c= INT by XBOOLE_0:def 10, NUMBERS:15,25;
    then consider x being object such that
    A3: x in REAL & not x in INT
    by TARSKI:def 3; 
    not x in {-infty,+infty} by A3, TARSKI:def 2;
    then x in ExtREAL & not x in ExtINT by A3, XXREAL_0:def 4, XBOOLE_0:def 3;
    hence thesis by XBOOLE_0:def 8;
  end;
end;

registration
  cluster ExtINT -> non empty infinite;
  coherence by Th2, FINSET_1:1, XBOOLE_0:def 8;
end;

definition
  let x be object;
  attr x is ext-integer means :Def2:
  x in ExtINT;
end;

registration
  cluster +infty -> ext-integer;
  coherence
  proof
    +infty in {+infty,-infty} by TARSKI:def 2;
    hence thesis by XBOOLE_0:def 3;
  end;
  cluster -infty -> ext-integer;
  coherence
  proof
    -infty in {+infty,-infty} by TARSKI:def 2;
    hence thesis by XBOOLE_0:def 3;
  end;
  cluster ext-integer -> ext-real for object;
  coherence;
  cluster ext-natural -> ext-integer for object;
  coherence
  proof
    let x be object;
    assume x is ext-natural;
    then x in ExtNAT by COUNTERS:def 2;
    hence thesis by Th2, TARSKI:def 3, XBOOLE_0:def 8;
  end;
end;

registration
  cluster zero ext-integer for object;
  existence
  proof
    take 0;
    thus thesis;
  end;
  cluster non zero ext-integer for object;
  existence
  proof
    take 1;
    thus thesis;
  end;
  cluster ext-integer for set;
  existence
  proof
    take 0;
    thus thesis;
  end;
  cluster -> ext-integer for Element of ExtINT;
  coherence;
  cluster -> ext-integer for Element of ExtNAT;
  coherence;
end;

definition
  mode ExtInt is ext-integer ExtReal;
end;

registration
  sethood of ExtInt
  proof
    take ExtINT;
    thus thesis by Def2;
  end;
end;

theorem Th4:
  for x being object
  holds x is ExtInt iff (x is Integer or x = -infty or x = +infty)
proof
  let x be object;
  thus x is ExtInt implies (x is Integer or x = -infty or x = +infty)
  proof
    assume A1: x is ExtInt;
    assume A2: not x is Integer & not x = -infty;
    x in INT \/ {-infty, +infty} by A1, Def2;
    then x in INT or x in {-infty, +infty} by XBOOLE_0:def 3;
    hence x = +infty by A2, TARSKI:def 2;
  end;
  thus (x is Integer or x = -infty or x = +infty) implies x is ExtInt
  proof
    assume x is Integer or x = -infty or x = +infty;
    then x in INT or x in {-infty,+infty} by INT_1:def 2, TARSKI:def 2;
    then x in INT \/ {-infty,+infty} by XBOOLE_0:def 3;
    hence x is ExtInt by Def2;
  end;
end;

registration
  cluster zero -> ext-integer for object;
  coherence;
  cluster integer -> ext-integer for object;
  coherence by Th4;
end;

registration
  cluster natural -> ext-integer for object;
  coherence;
end;

registration
  cluster positive for ExtInt;
  existence
  proof
    take 1;
    thus thesis;
  end;
  cluster non positive for ExtInt;
  existence
  proof
    take -1;
    thus thesis;
  end;
  cluster negative for ExtInt;
  existence
  proof
    take -1;
    thus thesis;
  end;
  cluster non negative for ExtInt;
  existence
  proof
    take 1;
    thus thesis;
  end;
end;

registration
  let m be ExtInt;
  cluster - m -> ext-integer;
  coherence
  proof
    per cases by Th4;
    suppose m is Integer;
      then reconsider M=m as Integer;
      -M is Integer;
      hence thesis by XXREAL_3:def 3;
    end;
    suppose m=-infty;
      hence thesis by XXREAL_3:def 3;
    end;
    suppose m=+infty;
      hence thesis by XXREAL_3:def 3;
    end;
  end;
end;

registration
  let m, n be ExtInt;
  cluster min(m, n) -> ext-integer;
  coherence by XXREAL_0:def 9;
  cluster max(m, n) -> ext-integer;
  coherence by XXREAL_0:def 10;
  cluster m + n -> ext-integer;
  coherence
  proof
    per cases by Th4;
    suppose A1: m is Integer;
      then reconsider M=m as Integer;
      per cases by Th4;
      suppose n is Integer;
        then reconsider N=n as Integer;
        M + N is Integer;
        hence thesis by XXREAL_3:def 2;
      end;
      suppose n=-infty;
        hence thesis by A1, XXREAL_3:def 2;
      end;
      suppose n=+infty;
        hence thesis by A1, XXREAL_3:def 2;
      end;
    end;
    suppose A2: m=-infty;
      per cases by Th4;
      suppose n is Integer;
        hence thesis by A2, XXREAL_3:def 2;
      end;
      suppose n=-infty;
        hence thesis by A2, XXREAL_3:def 2;
      end;
      suppose n=+infty;
        hence thesis by A2;
      end;
    end;
    suppose A3: m=+infty;
      per cases by Th4;
      suppose n is Integer;
        hence thesis by A3, XXREAL_3:def 2;
      end;
      suppose n=-infty;
        hence thesis by A3;
      end;
      suppose n=+infty;
        hence thesis by A3;
      end;
    end;
  end;
  cluster m * n -> ext-integer;
  coherence
  proof
    per cases by Th4;
    suppose m is Integer;
      then reconsider M=m as Integer;
      per cases by Th4;
      suppose n is Integer;
        then reconsider N=n as Integer;
        M * N is Integer;
        hence thesis by XXREAL_3:def 5;
      end;
      suppose B1: n=-infty;
        m is positive or m is negative or m is zero;
        hence thesis by B1, XXREAL_3:def 5;
      end;
      suppose B2: n=+infty;
        m is positive or m is negative or m is zero;
        hence thesis by B2, XXREAL_3:def 5;
      end;
    end;
    suppose A2: m=-infty;
      per cases by Th4;
      suppose n is Integer;
        n is positive or n is negative or n is zero;
        hence thesis by A2, XXREAL_3:def 5;
      end;
      suppose n=-infty;
        hence thesis by A2, XXREAL_3:def 5;
      end;
      suppose n=+infty;
        hence thesis by A2, XXREAL_3:def 5;
      end;
    end;
    suppose A3: m=+infty;
      per cases by Th4;
      suppose n is Integer;
        n is positive or n is negative or n is zero;
        hence thesis by A3, XXREAL_3:def 5;
      end;
      suppose n=-infty;
        hence thesis by A3, XXREAL_3:def 5;
      end;
      suppose n=+infty;
        hence thesis by A3;
      end;
    end;
  end;
end;

registration
  let m, n be ExtInt;
  cluster m - n -> ext-integer;
  coherence
  proof
    (- n) is ext-integer & m + (- n) is ext-integer &
    m - n = m + (- n) by XXREAL_3:def 4;
    hence thesis;
  end;
end;

registration
  cluster non negative -> ext-natural for ExtInt;
  coherence
  proof
    let x be ExtInt;
    assume A1: x is non negative;
    x is Integer or x = -infty or x = +infty by Th4;
    hence thesis by A1;
  end;
end;

theorem ThPosExtInt:
  for x being object
  holds x is positive ExtInt iff (x is positive Integer or x = +infty) by Th4;

theorem ThNegExtInt:
  for x being object
  holds x is negative ExtInt iff (x is negative Integer or x = -infty) by Th4;


begin :: 2. Definitions, abbreviations, and acronyms

definition
  func -0 -> object equals [0,0];
  coherence;
end;

theorem Th4:
  for n being Nat
  holds [n,0] <> +infty & [n,0] <> -infty
proof
  let n be Nat;
  A1: n in REAL by NUMBERS:19, TARSKI:def 3, ORDINAL1:def 12;
  +infty = [n,0] implies contradiction
  proof
    assume A2: +infty = [n,0];
    then +infty = {{n}, {n,0}} by TARSKI:def 5;
    then n = {n} or n = {n,0};
    then per cases;
    suppose n = {n};
      hence contradiction by ZFMISC_1:140;
    end;
    suppose n = {n,0};
      then n in n or n in 0 by TARSKI:def 2;
      hence contradiction by ORDINAL1:def 13;
    end;
  end;
  hence [n,0] <> +infty;
  thus [n,0] <> -infty by A1, XXREAL_0:def 3, XTUPLE_0:1, ORDINAL1:def 13;
end;

theorem Th5:
  not -0 in ExtREAL
proof
  [0,0] <> +infty & [0,0] <> -infty by Th4;
  then not (-0 in REAL or -0 in {+infty, -infty})
  by NUMBERS:def 1, ZFMISC_1:56, TARSKI:def 2;
  hence thesis by NUMBERS:def 5, XBOOLE_0:def 3, XXREAL_0:def 2,def 3;
end;

Lm1:
  for n being Nat
  holds not [n,0] in RAT+
proof
  let n be Nat;
  assume A1: [n,0] in RAT+;
  n in omega by ORDINAL1:def 12;
  then 0 <> {} by A1, ARYTM_3:33;
  hence contradiction by ORDINAL1:def 13;
end;

Lm2:
  for a,b being Nat
  st a = {b}
  holds b = {}
proof
  let a,b be Nat;
  assume A1: a = {b};
  then consider c being Nat such that
  A2: a = succ c by CARD_1:36;
  {b} = c \/ {c} by A1, A2, ORDINAL1:def 1;
  then c = {} by ZFMISC_1:38, ZFMISC_1:140;
  then a = {} \/ {{}} by A2, ORDINAL1:def 1;
  hence thesis by A1, ZFMISC_1:3;
end;

Lm3:
  for i being Nat st i <> 0
  holds not {i} in RAT+
proof
  let i be Nat such that
  A1: i <> 0;
  assume A2: {i} in RAT+;
  then per cases by ARYTM_3:29;
  suppose {i} in omega;
    then {} in {i} by ORDINAL3:8;
    hence contradiction by A1, ORDINAL1:def 13, TARSKI:def 1;
  end;
  suppose ex a,b being Element of omega st ({i} = [a,b] &
    a,b are_coprime & b <> {} & b <> 1);
    then consider a,b being Element of omega such that
    A3: ({i} = [a,b] & a,b are_coprime & b <> {} & b <> 1);
    {i} = {{a}, {a,b}} by A3, TARSKI:def 5;
    then {a} = {a,b} by ZFMISC_1:5;
    then A4: a = b by ZFMISC_1:5;
    then {i} = {{b}, {b,b}} by A3, TARSKI:def 5
            .= {{b}, {b}} by ENUMSET1:29
            .= {{b}} by ENUMSET1:29;
    hence contradiction by A3, Lm2, ZFMISC_1:3;
  end;
end;

Lm4:
  for i being Nat st i <> 0
  holds not [i,0] in DEDEKIND_CUTS
proof
  let i be Nat such that
  A1: i <> 0;
  assume [i,0] in DEDEKIND_CUTS;
  then [i,0] in {A where A is Subset of RAT+ : for r being Element of RAT+
  st r in A holds ((for s being Element of RAT+ st s <=' r holds s in A)
                   & ex s being Element of RAT+ st (s in A & r < s)) }
  by ARYTM_2:def 1;
  then consider A being Subset of RAT+ such that
  A2: [i,0] = A
    & for r being Element of RAT+ st r in A
      holds (for s being Element of RAT+ st s <=' r holds s in A)
          & ex s being Element of RAT+ st s in A & r < s;
  A = {{i}, {i,0}} by A2, TARSKI:def 5;
  then {i} in RAT+ & {i,0} in RAT+ by ZFMISC_1:32;
  hence contradiction by A1, Lm3;
end;

theorem Th6:
  for i being Nat
  holds not [i,0] in ExtREAL
proof
  let i be Nat;
  A1: not [i,0] in REAL
  proof
    per cases;
    suppose i = 0;
      hence thesis by Th5, NUMBERS:def 5, XBOOLE_0:def 3;
    end;
    suppose A1: i <> 0;
      then not ([i,0] in RAT+ or [i,0] in DEDEKIND_CUTS) by Lm1,Lm4;
      then A2: not [i,0] in REAL+ by ARYTM_2:def 2, XBOOLE_0:def 3;
      not [i,0] in [:{0},REAL+:] by A1, ZFMISC_1:105;
      hence thesis by A2, XBOOLE_0:def 3, NUMBERS:def 1;
    end;
  end;
  [i,0] <> +infty & [i,0] <> -infty by Th4;
  then not [i,0] in {+infty,-infty} by TARSKI:def 2;
  then not [i,0] in REAL \/ {+infty,-infty} by A1, XBOOLE_0:def 3;
  hence not [i,0] in ExtREAL by NUMBERS:def 5, XXREAL_0:def 2,def 3;
end;

registration
  let i be Nat;
  cluster [i,0] -> non ext-real;
  coherence by Th6, XXREAL_0:def 1;
end;

definition
  func NaN -> object equals [1,0];
  coherence;
end;

theorem
  not NaN in ExtREAL by Th6;


begin :: 3. Floating-point formats

reserve beta for positive Real;
reserve p for positive Nat;
reserve eMin for negative ExtInt;
reserve eMax for positive ExtNat;

theorem ThMaxMantissaValue:
  for d being XFinSequence of NAT
  st len d = p
  & (for i being Nat st i in dom d
     holds 0 <= d.i & d.i <= ([/beta\] - 1) * (beta to_power - i))
  & beta <> 1
  holds Sum d <= (([/beta\]-1)/(beta - 1))*(beta - (beta to_power (1 - p)))
proof
  let d be XFinSequence of NAT;
  assume A1: len d = p;
  assume A2: for i being Nat st i in dom d
             holds 0 <= d.i & d.i <= ([/beta\] - 1) * (beta to_power - i);
  assume A3: beta <> 1;
  set k0 = [/beta\] - 1;
  set c = (k0 (#) ((beta ") GeoSeq))|p;
  A4: dom c = p
  proof
    B1: dom (k0 (#) ((beta ") GeoSeq)) = NAT by FUNCT_2:def 1;
    p is Ordinal & p in omega by ORDINAL1:def 12;
    then for z being Ordinal st z in p
    holds z in omega by ORDINAL1:10;
    hence dom ((k0 (#) ((beta ") GeoSeq))|p) = p
    by B1, RELAT_1:62, ORDINAL1:def 5;
  end;
  then reconsider c as XFinSequence by AFINSQ_1:5;
  reconsider c as XFinSequence of REAL;
  
  A5: Sum c = (k0/(beta - 1)) * (beta - (beta to_power (1 - p)))
  proof
    consider n being Nat such that
    B1: p = n+1
    by NAT_1:6;
    B2: n = (n + 1) - 1 by XCMPLX_1:26
         .= p - 1 by B1;
    1" = 1; then
    B3: beta" <> 1 by A3;
    thus Sum c
    = (Partial_Sums (k0 (#) ((beta ") GeoSeq))).n by B1,AFINSQ_2:56
    .= (k0 (#) (Partial_Sums ((beta ") GeoSeq))).n by SERIES_1:9
    .= k0 * ((Partial_Sums ((beta ") GeoSeq)).n) by SEQ_1:9
    .= k0 * ((1 - ((beta ") to_power (n + 1)))/(1 - (beta "))) by B3,SERIES_1:22
    .= k0 * ((1 - ((1 * (beta ")) to_power p))/(1 - (1 * (beta ")))) by B1
    .= k0 * ((1 - ((1 * (beta ")) to_power p))/(1 - (1 / beta))) by XCMPLX_1:215
    .= k0 * ((1 - ((1/beta) to_power p))/(1 - (1 / beta))) by XCMPLX_1:215
    .= k0 * (1 * ((1 - ((1/beta) to_power p))/(1 - (1 / beta))))
    .= k0 * ((beta/beta) * ((1 - ((1/beta) to_power p))/(1 - (1 / beta))))
    by XCMPLX_1:60
    .= k0 * ((beta * (1 - ((1/beta) to_power p)))/(beta * (1 - (1 / beta))))
    by XCMPLX_1:76
    .= k0 * (((beta * 1) - (beta * ((1/beta) to_power p)))/(beta * 1 - beta*(1/beta)))
    .= k0 * ((beta - (beta * ((1/beta) to_power p)))/(beta - 1))
    by XCMPLX_1:106
    .= k0 * ((beta - (beta * (beta to_power -p)))/(beta - 1)) by POWER:32
    .= k0 * ((beta - ((beta to_power 1) * (beta to_power -p)))/(beta - 1))
    by POWER:25
    .= k0 * ((beta - (beta to_power (1 + (-p))))/(beta - 1))
    by POWER:27
    .= ((beta - (beta to_power (1 + (-p))))/(beta - 1)) * k0
    .= (k0/(beta - 1)) * (beta - (beta to_power (1 + (-p)))) by XCMPLX_1:75
    .= (k0/(beta - 1)) * (beta - (beta to_power (1 - p)));
  end;

  A6: len c = len d by A1,A4;
  for i being Nat st i in dom d holds d.i <= c.i
  proof
    let i be Nat;
    assume B1: i in dom d;
    B2: i in dom c by A6,B1;
    then B3: i in p by A4;
    c.i = ((k0 (#) ((beta ") GeoSeq))|p).i
       .= (k0 (#) ((beta ") GeoSeq)).i by B3, FUNCT_1:49
       .= k0 * (((beta ") GeoSeq).i) by SEQ_1:9
       .= k0 * ((beta ") to_power i) by PREPOWER:def 1
       .= k0 * ((1 * (beta ")) to_power i)
       .= k0 * ((1 / beta) to_power i) by XCMPLX_1:215
       .= k0 * (beta to_power -i) by POWER:32;
    hence d.i <= c.i by A2, B1;
  end;
  then Sum d <= Sum c by A6, AFINSQ_2:57;
  hence thesis by A5;
end;

definition
  let beta, p, eMin, eMax;
  func FLOAT_NUMBER(beta, p, eMin, eMax) -> Subset of ExtREAL equals
  {x where x is Real : ex M being Element of beta-radix_INT, e being Integer
   st x = M * (beta to_power (e - p + 1))
   & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
   & eMin - 1 < e & e <= eMax } \/ {+infty, -infty};
  coherence
  proof
    set NUM = {x where x is Real :
    ex M being Element of beta-radix_INT, e being Integer
    st x = M * (beta to_power (e - p + 1))
    & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
    & eMin - 1 < e & e <= eMax };
    set IT = NUM \/ {+infty, -infty};
    for x being object st x in IT holds x in ExtREAL
    proof
      let x be object;
      assume Z1: x in IT;
      then per cases by XBOOLE_0:def 3;
      suppose A1: x in NUM;
        then ex y being Real st x = y
        & ex M being Element of beta-radix_INT, e being Integer
        st y = M * (beta to_power (e - p + 1))
        & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
        & eMin - 1 < e & e <= eMax;
        then x in REAL by XREAL_0:def 1;
        hence x in ExtREAL by XBOOLE_0:def 3, XXREAL_0:def 4;
      end;
      suppose A2: x in {+infty, -infty};
        hence x in ExtREAL by XBOOLE_0:def 3, XXREAL_0:def 4;
      end;
    end;
    hence thesis by TARSKI:def 3;
  end;
end;

theorem LmSigh:
  for b being valid_radix Nat
  holds (([/b\] -1)/(b - 1)) * ((b to_power p) - 1) = (b to_power p) - 1
proof
  let b be valid_radix Nat;
  b > 1 by Def1;
  then b + (-1) > 1 + (-1) by XREAL_1:8;
  then b - 1 > 1 - 1;
  then b - 1 > 0;
  then ([/b\] - 1)/(b - 1) = 1 by XCMPLX_1:60;
  hence (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1) = 1 * ((b to_power p) - 1)
                                                    .= ((b to_power p) - 1);
end;

definition
  let b be valid_radix Nat, p, eMin, eMax;
  redefine func FLOAT_NUMBER(b, p, eMin, eMax) equals :DefSigh:
  {x where x is Real : ex M, e being Integer
   st x = M * (b to_power (e - p + 1)) & |.M.| <= ((b to_power p) - 1)
   & eMin - 1 < e & e <= eMax } \/ {+infty, -infty};
  compatibility
  proof
    let A be Subset of ExtREAL;
    set NEW = {x where x is Real : ex M, e being Integer
    st x = M * (b to_power (e - p + 1)) & |.M.| <= (b to_power p) - 1
    & eMin - 1 < e & e <= eMax } \/ {+infty, -infty};

    A1: (([/b\] -1)/(b - 1)) * ((b to_power p) - 1) = (b to_power p) - 1
    by LmSigh;

    for z being object
    holds z in FLOAT_NUMBER(b, p, eMin, eMax) iff z in NEW
    proof
      let z be object;
      thus z in FLOAT_NUMBER(b, p, eMin, eMax) implies z in NEW
      proof
        assume z in FLOAT_NUMBER(b, p, eMin, eMax);
        then per cases by XBOOLE_0:def 3;
        suppose z in {x where x is Real :
          ex M being Element of b-radix_INT, e being Integer
          st x = M * (b to_power (e - p + 1))
          & |.M.| <= (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1)
          & eMin - 1 < e & e <= eMax };
          then B1: ex x being Real st z = x
          & ex M being Element of b-radix_INT, e being Integer
          st x = M * (b to_power (e - p + 1))
          & |.M.| <= ((b to_power p) - 1)
          & eMin - 1 < e & e <= eMax by A1;
          INT = b-radix_INT by Def1, ThBRadixINTCompatibility;
          then z in {x where x is Real : ex M, e being Integer
          st x = M * (b to_power (e - p + 1)) & |.M.| <= (b to_power p) - 1
          & eMin - 1 < e & e <= eMax } by B1;
          hence z in NEW by XBOOLE_0:def 3;
        end;
        suppose z in {+infty,-infty};
          hence thesis by XBOOLE_0:def 3;
        end;
      end;
      thus z in NEW implies z in FLOAT_NUMBER(b, p, eMin, eMax)
      proof
        assume z in NEW;
        then per cases by XBOOLE_0:def 3;
        suppose z in {x where x is Real : ex M, e being Integer
          st x = M * (b to_power (e - p + 1)) & |.M.| <= (b to_power p) - 1
          & eMin - 1 < e & e <= eMax };
          then ex x being Real st x = z & ex M, e being Integer
          st x = M * (b to_power (e - p + 1)) & |.M.| <= (b to_power p) - 1
          & eMin - 1 < e & e <= eMax;
          then consider M, e being Integer such that
          B1: z = M * (b to_power (e - p + 1)) & |.M.| <= (b to_power p) - 1
          & eMin - 1 < e & e <= eMax;
          INT = b-radix_INT by Def1, ThBRadixINTCompatibility;
          then B2: M is Element of b-radix_INT by INT_1:def 2;
          z in {x where x is Real :
          ex M being Element of b-radix_INT, e being Integer
          st x = M * (b to_power (e - p + 1))
          & |.M.| <= (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1)
          & eMin - 1 < e & e <= eMax } by A1,B1,B2;
          hence z in FLOAT_NUMBER(b, p, eMin, eMax) by XBOOLE_0:def 3;
        end;
        suppose z in {+infty, -infty};
          hence z in FLOAT_NUMBER(b, p, eMin, eMax) by XBOOLE_0:def 3;
        end;
      end;
    end;
    hence A = FLOAT_NUMBER(b, p, eMin, eMax) iff A = NEW by TARSKI:2;
  end;
end;

theorem LmCeil:
  for x being Real
  for n being Integer
  st n < x & x <= n + 1
  holds [/x\] = n + 1
proof
  let x be Real;
  let n be Integer;
  assume A1: n < x;
  assume A2: x <= n + 1;
  n + 1 < x + 1 by A1, XREAL_1:8;
  hence [/x\] = n+1 by A2, INT_1:def 7;
end;

theorem LmZeroBound:
  0 <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
proof
  per cases;
  suppose A1: beta <= 1;
    then 0 < beta & beta <= 0 + 1;
    then [/beta\] + (-1) = 1 + (-1)  by LmCeil
                        .= 0;
    hence thesis;
  end;
  suppose A2: beta > 1;
    set a = (([/beta\] - 1)/(beta - 1));
    A3: 0 <= a
    proof
      beta - 1 > 1 - 1 by A2, XREAL_1:9;
      then B1: beta - 1 > 0;
      [/beta\] - 1 >= beta - 1 by XREAL_1:9, INT_1:def 7; 
      then ([/beta\] - 1)/(beta - 1) >= (beta - 1)/(beta - 1)
      by B1, XREAL_1:72;
      hence thesis by B1, XCMPLX_1:60;
    end;
    set b = beta to_power p;
    b >= 1 by A2, POWER:35;
    then b - 1 >= 1 - 1 by XREAL_1:9;
    hence thesis by A3;
  end;
end;

theorem ThZeroInFloatNumber:
  0 in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  reconsider M=0 as Element of beta-radix_INT by ThZeroInBetaINT;
  ex M being Element of beta-radix_INT, e being Integer
  st 0 = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax
  proof
    take M, e = 0;
    thus 0 = M * (beta to_power (e - p + 1));
    thus |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
    by LmZeroBound, COMPLEX1:44;
    thus eMin - 1 < e;
    thus e <= eMax;
  end;

  then 0 in {x where x is Real : ex M being Element of beta-radix_INT, e being Integer
   st x = M * (beta to_power (e - p + 1))
   & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
   & eMin - 1 < e & e <= eMax };
  hence thesis by XBOOLE_0:def 3;
end;

registration
  let beta, p, eMin, eMax;
  cluster FLOAT_NUMBER(beta, p, eMin, eMax) -> non empty;
  coherence by ThZeroInFloatNumber;
end;

registration
  let beta, p, eMin, eMax;
  cluster real for Element of FLOAT_NUMBER(beta, p, eMin, eMax);
  existence
  proof
    reconsider v=0 as Element of FLOAT_NUMBER(beta, p, eMin, eMax)
    by ThZeroInFloatNumber;
    take v;
    thus thesis;
  end;
  cluster -> ext-real for Element of FLOAT_NUMBER(beta, p, eMin, eMax);
  coherence by TARSKI:def 3;
end;

theorem St3200:
  -infty in FLOAT_NUMBER(beta, p, eMin, eMax)
  & +infty in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  -infty in {-infty,+infty} by TARSKI:def 2;
  hence -infty in FLOAT_NUMBER(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  +infty in {-infty,+infty} by TARSKI:def 2;
  hence +infty in FLOAT_NUMBER(beta, p, eMin, eMax) by XBOOLE_0:def 3;
end;

theorem Th11:
  for x being Real
  holds x in FLOAT_NUMBER(beta, p, eMin, eMax) iff
  (ex M being Element of beta-radix_INT, e being Integer
  st x = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax)
proof
  set NUM = {x where x is Real : ex M being Element of beta-radix_INT, e being Integer
   st x = M * (beta to_power (e - p + 1))
   & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
   & eMin - 1 < e & e <= eMax };
  let x be Real;
  thus x in FLOAT_NUMBER(beta, p, eMin, eMax) implies
  (ex M being Element of beta-radix_INT, e being Integer
  st x = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax)
  proof
    assume A1: x in FLOAT_NUMBER(beta, p, eMin, eMax);
    then x in NUM or x in {+infty, -infty} by XBOOLE_0:def 3;
    then ex y being Real st x = y & ex M being Element of beta-radix_INT, e being Integer
    st y = M * (beta to_power (e - p + 1))
    & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
    & eMin - 1 < e & e <= eMax by TARSKI:def 2;
    hence thesis;
  end;
  thus (ex M being Element of beta-radix_INT, e being Integer
  st x = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax) implies x in FLOAT_NUMBER(beta, p, eMin, eMax)
  proof
    assume ex M being Element of beta-radix_INT, e being Integer st x = M * (beta to_power (e - p + 1)) & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1) & eMin - 1 < e & e <= eMax;
    then x in NUM;
    hence x in FLOAT_NUMBER(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  end;
end;

theorem Th12a:
  for b being valid_radix Nat
  for x being Real
  holds x in FLOAT_NUMBER(b, p, eMin, eMax) iff
  (ex M, e being Integer
   st x = M * (b to_power (e - p + 1)) & |.M.| <= ((b to_power p) - 1)
   & eMin - 1 < e & e <= eMax)
proof
  let b be valid_radix Nat;
  let x be Real;
  hereby 
    assume x in FLOAT_NUMBER(b, p, eMin, eMax);
    then consider M being Element of b-radix_INT, e being Integer such that
    A1: x = M * (b to_power (e - p + 1))
    & |.M.| <= (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1)
    & eMin - 1 < e & e <= eMax
    by Th11;
    M in b-radix_INT &
    b-radix_INT = INT by Def1, ThBRadixINTCompatibility;
    then M in INT;
    then reconsider M1 = M as Integer;
    take M1, e;
    thus x = M1 * (b to_power (e - p + 1)) by A1;
    (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1) = (b to_power p) - 1 by LmSigh;
    hence |.M1.| <= ((b to_power p) - 1) by A1;
    thus eMin - 1 < e by A1;
    thus e <= eMax by A1;
  end;
  given M, e being Integer such that 
  A1: x = M * (b to_power (e - p + 1)) & |.M.| <= ((b to_power p) - 1)
  & eMin - 1 < e & e <= eMax;
  M in INT by INT_1:def 2;
  then A2: M in b-radix_INT by Def1, ThBRadixINTCompatibility;
  |.M.| <= (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1) by A1, LmSigh;
  hence x in FLOAT_NUMBER(b, p, eMin, eMax) by A1, A2, Th11;
end;

Lm7:
  for y being ExtReal st y in REAL
  holds y in FLOAT_NUMBER(beta, p, eMin, eMax)
  implies (- y) in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  let y be ExtReal;
  assume A1: y in REAL;
  assume y in FLOAT_NUMBER(beta, p, eMin, eMax);
  then consider M being Element of beta-radix_INT, e being Integer such that
  A2: y = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax
  by A1, Th11;
  A3: (- M) * (beta to_power (e - p + 1))
   = (-1) * ((M * (beta to_power (e - p + 1))) qua ExtReal)
  .= - y by A2, XXREAL_3:91;
  -M in beta-radix_INT & |.(- M).| = |.M.|
  by ThBetaRadixIntClosedUnderNegation, COMPLEX1:52;
  hence (- y) in FLOAT_NUMBER(beta, p, eMin, eMax) by A2,A3,Th11;
end;

theorem ThFloatClosedUnderNegation:
  for x being ExtReal
  holds x in FLOAT_NUMBER(beta, p, eMin, eMax)
  iff (- x) in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  let x be ExtReal;
  A1: - -infty = +infty & - +infty = -infty by XXREAL_3:def 3;
  x in REAL \/ {+infty, -infty} by XXREAL_0:def 1,def 4;
  then x in REAL or x in {+infty, -infty} by XBOOLE_0:def 3;
  then per cases by TARSKI:def 2;
  suppose CASE1: x in REAL;
    thus x in FLOAT_NUMBER(beta, p, eMin, eMax)
    implies (- x) in FLOAT_NUMBER(beta, p, eMin, eMax) by CASE1,Lm7;
  
    A2: - x in REAL by CASE1, XREAL_0:def 1;
    assume (- x) in FLOAT_NUMBER(beta, p, eMin, eMax);
    then - (- x) = x & - (- x) in FLOAT_NUMBER(beta, p, eMin, eMax) by Lm7,A2;
    hence x in FLOAT_NUMBER(beta, p, eMin, eMax);
    hence thesis by Lm7;
  end;
  suppose CASE2: x=+infty;
    hence thesis by A1, CASE2, St3200;
  end;
  suppose CASE3: x=-infty;
    hence thesis by A1, CASE3, St3200;
  end;
end;

theorem ThFiniteFloatClosedUnderNegation:
  for x being Real
  holds x in FLOAT_NUMBER(beta, p, eMin, eMax)
  iff (- x) in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  let x be Real;
  reconsider y=x as ExtReal;
  thus x in FLOAT_NUMBER(beta, p, eMin, eMax)
  implies -x in FLOAT_NUMBER(beta, p, eMin, eMax)
  proof
    assume x in FLOAT_NUMBER(beta, p, eMin, eMax);
    then -y in FLOAT_NUMBER(beta, p, eMin, eMax) by ThFloatClosedUnderNegation;
    hence (- x) in FLOAT_NUMBER(beta, p, eMin, eMax)
    by XXREAL_3:def 3;
  end;
  assume (- x) in FLOAT_NUMBER(beta, p, eMin, eMax);
  then -y in FLOAT_NUMBER(beta, p, eMin, eMax) by XXREAL_3:def 3;
  hence x in FLOAT_NUMBER(beta, p, eMin, eMax) by ThFloatClosedUnderNegation;
end;

theorem Th12:
  for x being positive Real
  holds x in FLOAT_NUMBER(beta, p, eMin, eMax) iff
  (ex M being Element of beta-radix_INT, e being Integer
  st x = M * (beta to_power (e - p + 1)) & 0 < M
  & M <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax)
proof
  let x be positive Real;
  thus x in FLOAT_NUMBER(beta, p, eMin, eMax) implies (ex M being Element of beta-radix_INT, e being Integer
  st x = M * (beta to_power (e - p + 1)) & 0 < M
  & M <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax)
  proof
    assume x in FLOAT_NUMBER(beta, p, eMin, eMax);
    then consider M being Element of beta-radix_INT, e being Integer such that
    A1: x = M * (beta to_power (e - p + 1))
    & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
    & eMin - 1 < e & e <= eMax by Th11;
    take M, e;
    thus x = M * (beta to_power (e - p + 1)) by A1;
    M > 0 by A1;
    then M = |.M.| by COMPLEX1:43;
    then M <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
    by A1;
    hence thesis by A1;
  end;
  given M being Element of beta-radix_INT, e being Integer such that 
  A2: x = M * (beta to_power (e - p + 1)) & 0 < M
  & M <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax;
  |.M.| = M by A2, COMPLEX1:43;
  hence thesis by A2, Th11;
end;

Lm17:
  for b being valid_radix Nat
  for p being non zero Nat
  holds b to_power (p - 1) <= (b to_power p) - 1
proof
  let b be valid_radix Nat;
  defpred P[Nat] means b to_power ($1 - 1) <= (b to_power $1) - 1;
  A1: P[1]
  proof
    b > 1 by Def1;
    then b - 1 >= 2 - 1 by NAT_1:23, XREAL_1:9;
    hence thesis by POWER:24;
  end;
  A2: for k being non zero Nat st P[k]
  holds P[k + 1]
  proof
    let k be non zero Nat;
    assume P[k];
    then B1: b * (b to_power (k - 1)) <= b * ((b to_power k) - 1)
    by XREAL_1:64;
    RHS: b * ((b to_power k) - 1) = ((b to_power 1) * (b to_power k)) - b
                                 .= (b to_power (1 + k)) - b by POWER:27;
    LHS: b * (b to_power (k - 1)) = (b to_power 1)*(b to_power (k - 1))
                                 .= b to_power (1 + (k - 1)) by POWER:27
                                 .= b to_power k;
    (b to_power (1 + k)) - b < (b to_power (1 + k)) - 1 by Def1, XREAL_1:10;
    hence thesis by B1, LHS, RHS, XXREAL_0:2;
  end;

  for k being non zero Nat holds P[k] from NAT_1:sch 10(A1, A2);
  hence b to_power (p - 1) <= (b to_power p) - 1;
end;

theorem Th53:
  for b being valid_radix Nat
  holds 1 in FLOAT_NUMBER(b, p, eMin, eMax)
proof
  let b be valid_radix Nat;
  ex M, e being Integer
  st 1 = M * (b to_power (e - p + 1)) & |.M.| <= ((b to_power p) - 1)
  & eMin - 1 < e & e <= eMax
  proof
    p >= 0 + 1 by INT_1:7;
    then A1: p - 1 in NAT by INT_1:5;
    then reconsider p1=p - 1 as Nat;
    b to_power (p - 1) = b |^ p1 by POWER:41;
    then reconsider M = b to_power (p - 1) as Integer;
    take M;
    take e = 0;
    thus M * (b to_power (e - p + 1))
          = b to_power ((p - 1) + (e - p + 1)) by POWER:27
         .= 1 by POWER:24;
    |.M.| = M by COMPLEX1:43;
    hence |.M.| <= (b to_power p) - 1 by Lm17;
    thus eMin - 1 < e;
    thus e <= eMax;
  end;
  hence 1 in FLOAT_NUMBER(b, p, eMin, eMax) by Th12a;
end;

definition
  let beta, p, eMin, eMax;
  func FLOAT(beta, p, eMin, eMax) -> set equals
  FLOAT_NUMBER(beta, p, eMin, eMax) \/ {-0, NaN};
  coherence;
end;

definition
  let beta, p, eMin, eMax;
  let IT be object;
  attr IT is (beta, p, eMin, eMax)-format_floating-point means :Def8a:
  IT in FLOAT(beta, p, eMin, eMax);
end;

registration
  let beta, p, eMin, eMax;
  cluster (beta, p, eMin, eMax)-format_floating-point for Number;
  existence
  proof
    -0 in {-0, NaN} by TARSKI:def 2;
    then -0 in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
    hence thesis by Def8a;
  end;
end;

:: Float of format beta, p, eMin, eMax
definition
  let beta, p, eMin, eMax;
  mode Float of beta, p, eMin, eMax is (beta, p, eMin, eMax)-format_floating-point Number;
end;

registration
  let beta, p, eMin, eMax;
  sethood of Float of beta, p, eMin, eMax
  proof
    take FLOAT(beta, p, eMin, eMax);
    thus thesis by Def8a;
  end;
end;

theorem ThZeroIsFloat:
  0 is Float of beta, p, eMin, eMax
proof
  0 in FLOAT_NUMBER(beta, p, eMin, eMax)
  by ThZeroInFloatNumber;
  then 0 in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  hence thesis by Def8a;
end;

registration
  let beta, p, eMin, eMax;
  cluster ext-real for Float of beta, p, eMin, eMax;
  existence
  proof
    reconsider v=0 as Float of beta,p,eMin,eMax by ThZeroIsFloat;
    take v;
    thus thesis;
  end;
  cluster real for Float of beta, p, eMin, eMax;
  existence
  proof
    reconsider v=0 as Float of beta,p,eMin,eMax by ThZeroIsFloat;
    take v;
    thus thesis;
  end;
end;

registration
  let beta, p, eMin, eMax;
  cluster zero for Float of beta, p, eMin, eMax;
  existence
  proof
    reconsider v=0 as Float of beta,p,eMin,eMax by ThZeroIsFloat;
    take v;
    thus thesis;
  end;
  cluster non zero for Float of beta, p, eMin, eMax;
  existence
  proof
    NaN in {-0,NaN} by TARSKI:def 2;
    then NaN in FLOAT(beta,p,eMin,eMax) by XBOOLE_0:def 3;
    then reconsider v=NaN as Float of beta,p,eMin,eMax by Def8a;
    take v;
    thus thesis;
  end;
end;

theorem St3201:
  -infty is Float of beta,p,eMin,eMax
  & +infty is Float of beta,p,eMin,eMax
proof
  -infty in FLOAT_NUMBER(beta, p, eMin, eMax) by St3200;
  then -infty in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  hence -infty is Float of beta, p, eMin, eMax by Def8a;
  +infty in FLOAT_NUMBER(beta, p, eMin, eMax) by St3200;
  then +infty in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  hence +infty is Float of beta, p, eMin, eMax by Def8a;
end;

definition
  let beta, p, eMin, eMax;
  let IT be Float of beta, p, eMin, eMax;
  attr IT is positive means :Def9a:
  ex x being positive ExtReal st IT = x;
  attr IT is negative means :Def9b:
  ex x being negative ExtReal st IT = x;
end;

registration
  let beta, p, eMin, eMax;
  cluster positive -> non zero ext-real for Float of beta,p,eMin,eMax;
  coherence by Def9a;
  cluster negative -> non zero ext-real for Float of beta,p,eMin,eMax;
  coherence by Def9b;
end;

registration
  let beta, p, eMin, eMax;
  cluster positive ext-real for Float of beta,p,eMin,eMax;
  existence
  proof
    reconsider v=+infty as Float of beta,p,eMin,eMax by St3201;
    take v;
    thus thesis by Def9a;
  end;
  cluster negative ext-real for Float of beta,p,eMin,eMax;
  existence
  proof
    reconsider v=-infty as Float of beta,p,eMin,eMax by St3201;
    take v;
    thus thesis by Def9b;
  end;
  cluster non positive ext-real for Float of beta,p,eMin,eMax;
  existence
  proof
    reconsider v=-infty as Float of beta,p,eMin,eMax by St3201;
    take v;
    thus thesis by Def9b;
  end;
  cluster non negative ext-real for Float of beta,p,eMin,eMax;
  existence
  proof
    reconsider v=+infty as Float of beta,p,eMin,eMax by St3201;
    take v;
    thus thesis by Def9a;
  end;
end;

theorem ThNegativeFloat:
  for v being negative Float of beta,p,eMin,eMax
  holds v < 0
proof
  let v be negative Float of beta,p,eMin,eMax;
  ex x being negative ExtReal st x = v by Def9b;
  hence v < 0;
end;

theorem ThPositiveFloat:
  for v being positive Float of beta,p,eMin,eMax
  holds v > 0
proof
  let v be positive Float of beta,p,eMin,eMax;
  ex x being positive ExtReal st x = v by Def9a;
  hence v > 0;
end;

theorem ThRealFloatsAreInFLOATNUMBER:
  for x being object
  holds x is ext-real Float of beta, p, eMin, eMax
  iff x in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  let x be object;
  hereby
    assume A1: x is ext-real Float of beta, p, eMin, eMax;
    then x in FLOAT(beta, p, eMin, eMax) by Def8a;
    then x in FLOAT_NUMBER(beta, p, eMin, eMax)
    or x in {-0, NaN} by XBOOLE_0:def 3;
    then x in FLOAT_NUMBER(beta, p, eMin, eMax)
    or x=-0 or x=NaN by TARSKI:def 2;
    hence x in FLOAT_NUMBER(beta, p, eMin, eMax) by A1;
  end;
  assume A2: x in FLOAT_NUMBER(beta, p, eMin, eMax);
  then x in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  then x is Float of beta, p, eMin, eMax by Def8a;
  hence x is ext-real Float of beta, p, eMin, eMax by A2;
end;

theorem St3300:
  for eMin being negative Integer
  for x being positive Float of b, p, eMin, eMax
  holds b to_power (eMin - p + 1) <= x
proof
  let eMin be negative Integer;
  let x be positive Float of b, p, eMin, eMax;
  x in REAL \/ {+infty,-infty} by XXREAL_0:def 1,def 4;
  then x in REAL or x in {+infty,-infty} by XBOOLE_0:def 3;
  then per cases by TARSKI:def 2;
  suppose A1: x in REAL;
    then reconsider X=x as positive Real by ThPositiveFloat;
    x in FLOAT(b, p, eMin, eMax) by Def8a;
    then x in FLOAT_NUMBER(b, p, eMin, eMax) by A1, ThRealFloatsAreInFLOATNUMBER;
    then consider M being Element of b-radix_INT, e being Integer such that
    A3: X = M * (b to_power (e - p + 1)) & 0 < M
    & M <= (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1)
    & eMin - 1 < e & e <= eMax by Th12;
    eMin - 1 + 1 <= e by A3, INT_1:7;
    then eMin + (1 - p) <= e + (1 - p) by XREAL_1:6;
    then A4: (b to_power (eMin - p + 1)) <= (b to_power (e - p + 1))
    by Def1, Th1;
    1 <= M by A3, ThSmallestPositiveBetaRadixInt;
    then 1 * (b to_power (e - p + 1)) <= M * (b to_power (e - p + 1))
    by XREAL_1:64;
    hence (b to_power (eMin - p + 1)) <= x by A3, A4, XXREAL_0:2;
  end;
  suppose x=+infty;
    hence b to_power (eMin - p + 1) <= x by XREAL_0:def 1, XXREAL_0:9;
  end;
  suppose x=-infty;
    hence thesis by ThPositiveFloat;
  end;
end;

theorem ThPositiveFloatIsRealOrInfinity:
  for v being positive Float of beta, p, eMin, eMax
  holds v is real or v = +infty
proof
  let v be positive Float of beta, p, eMin, eMax;
  assume not v is real;
  then A1: not v in REAL;
  ex x being positive ExtReal st x = v by Def9a;
  hence v = +infty by A1, XXREAL_0:14;
end;

theorem ThNegativeFloatIsRealOrInfinity:
  for v being negative Float of beta, p, eMin, eMax
  holds v is real or v = -infty
proof
  let v be negative Float of beta, p, eMin, eMax;
  assume not v is real;
  then A1: not v in REAL;
  ex x being negative ExtReal st x = v by Def9b;
  hence v = -infty by A1, XXREAL_0:14;
end;

theorem St3301:
  for eMin being negative Integer
  for x being real Float of beta, p, eMin, eMax
  ex n being Element of beta-radix_INT
  st n*(beta to_power (eMin - p + 1)) = x
proof
  let eMin be negative Integer;
  let x be real Float of beta, p, eMin, eMax;
  x in FLOAT_NUMBER(beta, p, eMin, eMax) by ThRealFloatsAreInFLOATNUMBER;
  then consider M being Element of beta-radix_INT, e being Integer such that
  A1: x = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax
  by Th11;
  (eMin - 1) + 1 <= e by A1, INT_1:7;
  then eMin - eMin <= e - eMin by XREAL_1:9;
  then e - eMin in NAT by INT_1:3;
  then reconsider n = M*(beta to_power (e - eMin)) as Element of beta-radix_INT
  by ThLeftShiftBetaRadixINT;
  take n;
  thus n*(beta to_power (eMin - p + 1))
   = (M * (beta to_power (e - eMin))) * (beta to_power (eMin - p + 1))
  .= M * ((beta to_power (e - eMin)) * (beta to_power (eMin - p + 1)))
  .= M * (beta to_power ((e - eMin) + (eMin - p + 1))) by POWER:27
  .= M * (beta to_power (e - p + 1))
  .= x by A1;
end;

theorem St3302:
  b in INT implies
  for eMin being negative Integer
  for x being real Float of b, p, eMin, eMax
  ex n being Integer
  st n*(b to_power (eMin - p + 1)) = x
proof
  assume b in INT;
  then A1: b in NAT by INT_1:3;
  let eMin be negative Integer;
  let x be real Float of b, p, eMin, eMax;
  b is Nat by A1, ORDINAL1:def 12;
  then b-radix_INT = INT by Def1, A1, ThBRadixINTCompatibility;
  then ex n being Element of INT
  st n*(b to_power (eMin - p + 1)) = x by St3301;
  hence thesis by INT_1:def 2;
end;

theorem ThSmallestPositiveFloat:
  for eMin being negative Integer
  for b being valid_radix Nat
  for x being positive Float of b, p, eMin, eMax
  holds (b to_power (eMin - p + 1)) <= x
proof
  let eMin be negative Integer;
  let b be valid_radix Nat;
  let x be positive Float of b, p, eMin, eMax;
  A1: x in FLOAT_NUMBER(b, p, eMin, eMax) by ThRealFloatsAreInFLOATNUMBER;
  per cases by ThPositiveFloatIsRealOrInfinity;
  suppose A2: x is real;
    b in NAT by ORDINAL1:def 12;
    then b in INT by NUMBERS:17;
    then consider n being Integer such that
    A3: n*(b to_power (eMin - p + 1)) = x
    by A2, St3302;
    x is positive real by A2;
    then n is positive by A3;
    then 0 + 1 <= n by INT_1:7;
    then 1 * (b to_power (eMin - p + 1)) <= n * (b to_power (eMin - p + 1))
    by XREAL_1:64;
    hence (b to_power (eMin - p + 1)) <= x by A3;
  end;
  suppose x = +infty;
    hence thesis by XXREAL_0:3;
  end;
end;

theorem ThSmallestNegativeFloat:
  for eMin being negative Integer
  for b being valid_radix Nat
  for x being negative Float of b, p, eMin, eMax
  holds x <= -(b to_power (eMin - p + 1))
proof
  let eMin be negative Integer;
  let b be valid_radix Nat;
  let x be negative Float of b, p, eMin, eMax;
  x in FLOAT_NUMBER(b, p, eMin, eMax) by ThRealFloatsAreInFLOATNUMBER;
  per cases by ThNegativeFloatIsRealOrInfinity;
  suppose A1: x is real;
    b in NAT by ORDINAL1:def 12;
    then consider n being Integer such that
    A2: n*(b to_power (eMin - p + 1)) = x
    by A1, St3302, NUMBERS:17;
    x is negative real by A1;
    then n is negative by A2;
    then n <= -1 by INT_1:8;
    then n * (b to_power (eMin - p + 1)) <= (-1) * (b to_power (eMin - p + 1))
    by XREAL_1:64;
    hence x <= - (b to_power (eMin - p + 1)) by A2;
  end;
  suppose x = -infty;
    hence thesis by XXREAL_0:5;
  end;
end;

definition
  let beta, p, eMin, eMax;
  let IT be Float of beta, p, eMin, eMax;
  attr IT is normal means :Def8:
  IT is real & IT <> 0 if eMin = -infty
  otherwise IT is real & ex x being Real, iMin being negative Integer
  st iMin = eMin & x = IT & beta to_power iMin <= |.x.|;
  consistency;
end;

registration
  let beta, p, eMin, eMax;
  cluster normal -> real for Float of beta, p, eMin, eMax;
  coherence
  proof
    let v be Float of beta, p, eMin, eMax;
    assume A1: v is normal;
    per cases;
    suppose eMin = -infty;
      hence thesis by A1, Def8;
    end;
    suppose eMin <> -infty;
      hence thesis by A1, Def8;
    end;
  end;
end;

theorem ThNormalFloatCriteriaFiniteExp:
  for eMin being negative Integer
  for v being Float of beta, p, eMin, eMax
  holds v is normal iff ex x being Real st x = v
  & beta to_power eMin <= |.x.|
proof
  let eMin be negative Integer;
  let v be Float of beta, p, eMin, eMax;
  thus v is normal implies ex x being Real st x = v
  & beta to_power eMin <= |.x.|
  proof
    assume v is normal;
    then ex x being Real, iMin being negative Integer st iMin = eMin
    & x = v
    & beta to_power iMin <= |.x.| by Def8;
    hence thesis;
  end;
  given x being Real such that 
  A1: x = v & beta to_power eMin <= |.x.|;
  thus v is normal by A1, Def8;
end;

Lm19:
  b to_power (1 - p) <= 1
  & 1 <= b to_power (p - 1)
proof
  A1: p >= 0 + 1 by INT_1:7;
  then 1 - p <= 1 - 1 by XREAL_1:13;
  then b to_power (1 - p) <= b to_power 0 by Def1,Th1;
  hence b to_power (1 - p) <= 1 by POWER:24;
  1 - 1 <= p - 1 by A1, XREAL_1:9;
  then b to_power 0 <= b to_power (p - 1) by Def1,Th1;
  hence 1 <= b to_power (p - 1) by POWER:24;
end;

Lm20:
  for eMax being positive Integer
  holds b <= b to_power eMax
proof
  let eMax be positive Integer;
  0 + 1 <= eMax by INT_1:7;
  then b to_power 1 <= b to_power eMax by Def1,Th1;
  hence b <= b to_power eMax by POWER:25;
end;

Lm21:
  for eMax being positive Integer
  holds b * (b - 1) <= (b to_power eMax)*(b - (b to_power (1 - p)))
proof
  let eMax be positive Integer;
  A1: 0 <= b - 1 & 0 <= b
  proof
    b > 1 by Def1;
    hence 0 <= b - 1 by XREAL_1:48;
    thus 0 <= b;
  end;
  1 >= b to_power (1 - p) by Lm19;
  then A2: b - 1 <= b - (b to_power (1 - p)) by XREAL_1:13;
  b <= b to_power eMax by Lm20;
  hence b * (b - 1) <= (b to_power eMax)*(b - (b to_power (1 - p)))
  by A1, A2, XREAL_1:66;
end;

theorem ThNormalFloatInNegInfty:
  for x being Float of beta, p, eMin, eMax
  st x=1 & eMin=-infty
  holds x is normal
proof
  let x be Float of beta, p, eMin, eMax;
  assume A1: x=1;
  assume A2: eMin=-infty;
  1 in NAT;
  then x is real by A1, NUMBERS:19;
  then x in FLOAT_NUMBER(beta, p, eMin, eMax) by ThRealFloatsAreInFLOATNUMBER;
  hence x is normal by A1,A2,Def8;
end;

theorem ThNormalFloatInPosInfty:
  for x being Float of b, p, eMin, eMax
  st x=1 & eMax=+infty
  holds x is normal
proof
  let x be Float of b, p, eMin, eMax;
  assume A1: x=1;
  assume A2: eMax=+infty;
  per cases;
  suppose eMin=-infty;
    hence thesis by ThNormalFloatInNegInfty,A1;
  end;
  suppose A3: eMin <> -infty;
    then reconsider iMin = eMin as negative Integer by ThNegExtInt;
    reconsider x1=x as Real by A1;
    b > 1 by Def1;
    then b to_power iMin < |.x1.| by A1,COMPLEX1:48,POWER:36;
    hence x is normal by A2,Def8;
  end;
end;

theorem ThExistenceNormalFloat:
  for b being valid_radix Nat
  ex x being Float of b, p, eMin, eMax
  st x is normal
proof
  let b be valid_radix Nat;
  1 in FLOAT_NUMBER(b, p, eMin, eMax) by Th53; then
  1 in FLOAT(b, p, eMin, eMax) by XBOOLE_0:def 3; then
  A1: 1 is Float of b, p, eMin, eMax by Def8a;
  per cases;
  suppose eMin=-infty;
    hence thesis by A1, ThNormalFloatInNegInfty;
  end;
  suppose eMax=+infty;
    hence thesis by A1, ThNormalFloatInPosInfty;
  end;
  suppose A2: eMin <> -infty & eMax <> +infty;
    then reconsider iMin=eMin as negative Integer by ThNegExtInt;
    reconsider iMax=eMax as positive Integer by A2, ThPosExtInt;
    reconsider x0 = 1 as Float of b, p, eMin, eMax by A1;
    take x0;
    ex x being Real st x = x0
    & b to_power iMin <= |.x.|
    & |.x.| <= (b to_power iMax)*(b - (b to_power (1 - p)))
    proof
      take x = 1;
      thus x = x0;
      b > 1 & iMin < 0 by Def1;
      hence b to_power iMin <= |.x.| by COMPLEX1:48, POWER:36;
      1 < b by Def1;
      then A3: 1 + 1 <= b by INT_1:7;
      then 2 + (- 1) <= b + (- 1) by XREAL_1:6;
      then A4: 2 * 1 <= b * (b - 1) by A3, XREAL_1:66;
      b * (b - 1) <= (b to_power iMax)*(b - (b to_power (1 - p))) by Lm21;
      then 2 <= (b to_power iMax)*(b - (b to_power (1 - p))) by A4, XXREAL_0:2;
      hence |.x.| <= (b to_power iMax)*(b - (b to_power (1 - p)))
      by COMPLEX1:48, XXREAL_0:2;
    end;
    hence x0 is normal by Def8;
  end;
end;

registration
  let b be valid_radix Nat, p, eMin, eMax;
  cluster normal for Float of b, p, eMin, eMax;
  existence by ThExistenceNormalFloat;
end;

definition
  let beta, p, eMin, eMax;
  let IT be Float of beta, p, eMin, eMax;
  attr IT is subnormal means :Def9:
  ex x being Real st x = IT &
  ex iMin being negative Integer st iMin = eMin
  & 0 < |.x.| & |.x.| < beta to_power iMin;
end;

registration
  let beta, p, eMin, eMax;
  cluster subnormal -> real for Float of beta, p, eMin, eMax;
  coherence;
end;

theorem ThRealFloatsAreNumbers:
  for x being Real
  holds x in FLOAT_NUMBER(beta, p, eMin, eMax)
  iff x in FLOAT(beta, p, eMin, eMax)
proof
  let x be Real;
  thus x in FLOAT_NUMBER(beta, p, eMin, eMax)
  implies x in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  thus x in FLOAT(beta, p, eMin, eMax)
  implies x in FLOAT_NUMBER(beta, p, eMin, eMax)
  proof
    assume A1: x in FLOAT(beta, p, eMin, eMax);
    not -0 in ExtREAL & not NaN in ExtREAL by Th6;
    then {-0, NaN} misses ExtREAL by ZFMISC_1:51;
    then A2: {-0, NaN} /\ REAL = {} by XBOOLE_1:63, NUMBERS:31, XBOOLE_0:def 7;
    x in REAL by XREAL_0:def 1;
    then not x in {-0, NaN} by A2,XBOOLE_0:def 4;
    hence x in FLOAT_NUMBER(beta, p, eMin, eMax) by A1,XBOOLE_0:def 3;
  end;
end;

theorem
  p = 1 implies
  for b being valid_radix Nat
  for eMin being negative Integer
  holds not ex v being Float of b, p, eMin, eMax
  st v is subnormal
proof
  assume A1: p = 1;
  let b be valid_radix Nat;
  let eMin be negative Integer;
  set x = b to_power (eMin - p + 1);
  b > 1 by Def1;
  then x > 0 by POWER:34;
  then reconsider x as positive Real;
  A2: x = b to_power eMin by A1;
  then for v being positive Float of b, p, eMin, eMax
  holds x <= v by ThSmallestPositiveFloat;

  for v being Float of b, p, eMin, eMax
  holds not v is subnormal
  proof
    let v be Float of b, p, eMin, eMax;
    assume v is subnormal;
    then consider x0 being Real such that
    A3: x0 = v & 0 < |.x0.| & |.x0.| < b to_power eMin
    by Def9;
    A4: |.x0.| < x by A2,A3;
    A5: x0 in FLOAT_NUMBER(b, p, eMin, eMax)
    & x0 is Float of b, p, eMin, eMax
    by A3, ThRealFloatsAreInFLOATNUMBER;
    0 < -x0 or 0 < x0 by A3, COMPLEX1:71;
    then per cases;
    suppose x0 is positive;
      then x0 is positive Float of b, p, eMin, eMax by A5, Def9a;
      then (b to_power (eMin - p + 1)) <= x0 by ThSmallestPositiveFloat;
      hence contradiction by A4, COMPLEX1:43;
    end;
    suppose A6: x0 is negative;
      then x0 is negative Float of b, p, eMin, eMax by A5, Def9b;
      then -(- x) <= -x0 by A5, ThSmallestNegativeFloat, XREAL_1:24;
      hence contradiction by A4, A6, COMPLEX1:70;
    end;
  end;
  hence thesis;
end;

theorem
  eMin = -infty implies not ex v being Float of beta, p, eMin, eMax
  st v is subnormal by Def9;

theorem ThZeroIsNotNormal:
  for x being Float of beta, p, eMin, eMax
  st x = 0
  holds not x is normal & not x is subnormal
proof
  let x be Float of beta, p, eMin, eMax;
  assume A1: x = 0;
  thus not x is normal
  proof
    assume A2: x is normal;
    per cases;
    suppose eMin = -infty;
      then x <> 0 by A2, Def8;
      hence contradiction by A1;
    end;
    suppose eMin <> -infty;
      then ex x0 being Real, iMin being negative Integer
      st iMin = eMin
      & x0 = x
      & beta to_power iMin <= |.x0.| by A2, Def8;
      then 0 < |.0.| by A1, Def1;
      hence contradiction by COMPLEX1:44;
    end;
  end;
  thus not x is subnormal
  proof
    assume x is subnormal;
    then ex x0 being Real st x0 = x &
    ex iMin being negative Integer st iMin = eMin
    & 0 < |.x0.| & |.x0.| < beta to_power iMin by Def9;
    then 0 < |.0.| by A1;
    hence contradiction by COMPLEX1:44;
  end;
end;

registration
  let beta, p, eMin, eMax;
  cluster zero -> non normal for Float of beta, p, eMin, eMax;
  coherence by ThZeroIsNotNormal;
  cluster zero -> non subnormal for Float of beta, p, eMin, eMax;
  coherence by ThZeroIsNotNormal;
  cluster normal -> non zero for Float of beta, p, eMin, eMax;
  coherence by ThZeroIsNotNormal;
  cluster subnormal -> non zero for Float of beta, p, eMin, eMax;
  coherence by ThZeroIsNotNormal;
end;

theorem ThBabyExistenceSubnormalFloat:
  p > 1 implies
  for b being valid_radix Nat
  for eMin being negative Integer
  ex v being Float of b, p, eMin, eMax
  st v = (b to_power (1 - p))*(b to_power eMin)
  & v is subnormal
proof
  assume A1: p > 1;
  let b be valid_radix Nat;
  let eMin be negative Integer;
  ex v being Float of b, p, eMin, eMax
  st v = (b to_power (1 - p))*(b to_power eMin)
  proof
    set M = 1, e = eMin;
    set x = M * (b to_power (e - p + 1));
    reconsider x as positive Real;
    eMin + (- 1) < e + 0 by XREAL_1:8;
    then B1: x = M * (b to_power (e - p + 1))
    & 0 < M & M <= b to_power (p - 1)
    & eMin - 1 < e & e <= eMax by Lm19;
    then |.M.| <= b to_power (p - 1)
    & b to_power (p - 1) <= ((b to_power p) - 1) by Lm17, COMPLEX1:43;
    then |.M.| <= ((b to_power p) - 1) by XXREAL_0:2;
    then x in FLOAT_NUMBER(b,p,eMin,eMax) by B1, Th12a;
    then reconsider v=x as Float of b, p, eMin, eMax by ThRealFloatsAreInFLOATNUMBER;
    take v;
    x = b to_power ((1 - p) + e)
     .= (b to_power (1 - p)) * (b to_power e) by POWER:27;
    hence thesis;
  end;
  then consider v being Float of b, p, eMin, eMax such that
  A2: v = (b to_power (1 - p))*(b to_power eMin);
  take v;
  thus v = (b to_power (1 - p))*(b to_power eMin) by A2;
  ex x being Real st x = v & 0 < |.x.| & |.x.| < b to_power eMin
  proof
    reconsider x = (b to_power (1 - p))*(b to_power eMin) as Real;
    take x;
    thus x = v by A2, Def8a;
    B1: b > 1 by Def1;
    B2: x = b to_power (1 - p + eMin) by POWER:27;
    thus 0 < |.x.|;
    1 + 1 <= p by A1, INT_1:7;
    then 1 - p <= 1 - 2 by XREAL_1:10;
    then 1 - p <= -1;
    then 1 - p + eMin < 0 + eMin by XREAL_1:8;
    then b to_power (1 - p + eMin) < b to_power eMin by B1, POWER:39;
    hence |.x.| < b to_power eMin by B2, COMPLEX1:43;
  end;
  hence v is subnormal;
end;

theorem ThExistenceSubnormalFloat:
  p > 1 implies
  for b being valid_radix Nat
  for eMin being negative Integer
  ex v being Float of b, p, eMin, eMax
  st v is subnormal
proof
  assume A1: p > 1;
  let b be valid_radix Nat;
  let eMin be negative Integer;
  ex v being Float of b, p, eMin, eMax st
  v = (b to_power (1 - p))*(b to_power eMin)
  & v is subnormal
  by A1, ThBabyExistenceSubnormalFloat;
  hence thesis;
end;

registration
  let b, p be valid_radix Nat;
  let eMin be negative Integer;
  let eMax;
  cluster subnormal for Float of b, p, eMin, eMax;
  existence by Def1, ThExistenceSubnormalFloat;
end;

definition
  mode Binary32Float is Float of 2, 24, -126, 127;
  mode Binary64Float is Float of 2, 53, -1022, 1023;
  mode Binary128Float is Float of 2, 113, -16382, 16383;
  mode Decimal64Float is Float of 10, 16, -383, 384;
  mode Decimal128Float is Float of 10, 34, -6143, 6144;
end;
