:: Floating-point Arithmetic
:: by Alexander M. Nelson
::
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ
 vocabularies NUMBERS, ORDINAL1, CARD_1, SUBSET_1, XBOOLE_0, ARYTM_2, ARYTM_3,
   ZFMISC_1, XCMPLX_0, XREAL_0, XXREAL_0, TARSKI, FUNCT_7, RELAT_1,
   REAL_1, INT_1, PREPOWER, POWER, ARYTM_1, NAT_1, COUNTERS,
   COMPLEX1, FINSET_1, NEWTON, PRE_TOPC, FUZNUM_1,
   FLOAT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, ARYTM_2, ARYTM_3,
   XXREAL_3, NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0, NEWTON, INT_1, COUNTERS, COMPLEX1, FINSET_1,
   PREPOWER, POWER;
 constructors ARYTM_2, ARYTM_3, NUMBERS, XCMPLX_0, XXREAL_0, XXREAL_3, XREAL_0, INT_1,
   COMPLEX1, NEWTON, FINSET_1, COUNTERS, PREPOWER, POWER;
 registrations ORDINAL1, XBOOLE_0, COUNTERS, NUMBER01,
   XCMPLX_0, XXREAL_0, XREAL_0, XXREAL_3, FINSET_1, RAT_1, INT_1,
   FOMODEL0, NEWTON;
 requirements REAL, SUBSET, BOOLE, NUMERALS, ARITHM;
 theorems ARYTM_2, ARYTM_3, CARD_1, COMPLEX1, COUNTERS, ENUMSET1, FINSET_1, INT_1, NUMBERS, ORDINAL1, ORDINAL2, ORDINAL3, POWER,
   TARSKI, XBOOLE_0, XBOOLE_1, XCMPLX_0, XCMPLX_1, XREAL_0, XREAL_1, XXREAL_0, XXREAL_3, XTUPLE_0, ZFMISC_1;

begin :: Preliminaries

definition
  let IT be Real;
  attr IT is valid_radix means :Def1:
  IT > 1;
end;

registration
  cluster valid_radix for Real;
  existence
  proof
    take x=2;
    thus thesis by Def1;
  end;
end;

registration
  cluster valid_radix for Nat;
  existence
  proof
    take 2;
    thus thesis;
  end;
end;

registration
  cluster valid_radix -> positive for Real;
  coherence by Def1, XXREAL_0:def 6;
end;

registration
  let x be positive Real;
  let y be Real;
  cluster x to_power y -> positive;
  coherence by POWER:34;
end;

theorem Th1:
  for x,y,z being Real
  st x <= y & z > 1
  holds z to_power x <= z to_power y
proof
  let x,y,z be Real;
  assume A1: x <= y;
  assume A2: z > 1;
  x < y or x = y by A1, XXREAL_0:1;
  hence thesis by A2, POWER:39;
end;

theorem ThNatPowers:
  for x being Real
  for y being Real
  st x in NAT & y in NAT
  holds x to_power y in NAT
proof
  let x be Real;
  let y be Real;
  assume A1: x in NAT;
  assume A2: y in NAT;
  reconsider X=x, Y=y as Nat by A1,A2;
  X to_power Y = X |^ Y by POWER:41;
  hence x to_power y in NAT by ORDINAL1:def 12;
end;

reserve b for valid_radix Real;

theorem Th1b:
  for x being positive Real
  for N being Integer
  holds (b to_power N <= x & x < b to_power (N + 1))
  iff N = [\ log(b, x) /]
proof
  let x be positive Real;
  let N be Integer;
  thus (b to_power N <= x & x < b to_power (N + 1)) implies N = [\ log(b, x) /]
  proof
    assume A1: b to_power N <= x;
    assume A2: x < b to_power (N + 1);
    A3: b <> 1 & b > 1 by Def1;
    
    A4: N <= log(b, x)
    proof
      b to_power N = x or b to_power N < x by A1, XXREAL_0:1;
      then per cases;
      suppose b to_power N = x;
        hence thesis by A3, POWER:def 3;
      end;
      suppose A5: b to_power N < x;
        A6: b to_power N > 0 by POWER:34;
        then N = log(b, b to_power N) by A3, POWER:def 3;
        hence thesis by A3, A5, A6, POWER:57;
      end;
    end;
    log(b,x) < N + 1
    proof
      b to_power (N + 1) > 0 by POWER:34;
      then N + 1 = log(b, b to_power (N + 1)) by A3, POWER:def 3;
      hence log(b,x) < (N+1) by A2, A3, POWER:57;
    end;
    then log(b,x) - 1 < (N + 1) - 1 by XREAL_1:14;
    hence thesis by A4, INT_1:def 6;
  end;
  thus N = [\ log(b, x) /] implies (b to_power N <= x & x < b to_power (N + 1))
  proof
    assume N = [\ log(b, x) /];
    then N <= log(b, x) & log(b,x) - 1 < N by INT_1:def 6;
    then N <= log(b, x) & log(b,x) - 1 + 1 < N + 1 by XREAL_1:8;
    then A1: N <= log(b, x) & log(b, x) < N + 1;
    A2: b to_power N <= b to_power (log(b,x))
      & b to_power (log(b,x)) < b to_power (N + 1)
    proof
      B1: b > 1 by Def1;
      thus b to_power N <= b to_power (log(b,x))
      proof
        per cases by A1, XXREAL_0:1;
        suppose N = log(b, x);
          hence thesis;
        end;
        suppose N < log(b, x);
          hence thesis by B1, POWER:39;
        end;
      end;
      thus b to_power (log(b,x)) < b to_power (N + 1) by A1, B1, POWER:39;
    end;
    b > 0 & b <> 1 by Def1;
    hence (b to_power N <= x & x < b to_power (N + 1)) by A2, POWER:def 3;
  end;
end;

theorem Th2:
  for x being positive Real
  holds 1 <= x * (b to_power (-[\ log(b, x) /]))
           & x * (b to_power (-[\ log(b, x) /])) < b
proof
  let x be positive Real;
  set N = [\ log(b, x) /];
  A1: b > 0 & b <> 1 by Def1;
  A2: b to_power N > 0 by POWER:34;
  A3: (b to_power N) * (b to_power (- N))
     = b to_power (N + (- N)) by POWER:27
    .= 1 by POWER:24;

  thus 1 <= x * (b to_power (- N))
  proof
    set z = b to_power N;
    1 / z = b to_power (- N) by POWER:28;
    hence 1 <= x * (b to_power (- N)) by A2, A3, Th1b, XREAL_1:64;
  end;

  thus x * (b to_power (- N)) < b
  proof
    b to_power (N + 1) = (b to_power 1) * (b to_power N) by POWER:27
                      .= b * (b to_power N) by POWER:25;
    then B1: (b to_power (N + 1)) * (b to_power (- N))
     = b * ((b to_power N) * (b to_power (- N)))
    .= b by A3;
    0 < (b to_power (- N)) by POWER:34;
    hence x * (b to_power (- N)) < b by Th1b, B1, XREAL_1:68;
  end;
end;

definition
  func ExtINT -> Subset of ExtREAL equals
  INT \/ {-infty,+infty};
  coherence
  proof
    INT c= REAL & REAL c= ExtREAL by XBOOLE_0:def 8, NUMBERS:5,31; then
    A1: INT c= ExtREAL by XBOOLE_1:1;
    {-infty,+infty} c= ExtREAL by XBOOLE_1:7, XXREAL_0:def 4;
    hence thesis by A1, XBOOLE_1:8;
  end;
end;

theorem Th2:
  INT c< ExtINT & ExtNAT c< ExtINT & ExtINT c< ExtREAL
proof
  thus INT c< ExtINT
  proof
    +infty in {+infty,-infty} by TARSKI:def 2; then
    A1: +infty in ExtINT by XBOOLE_0:def 3;
    not +infty in INT;
    hence thesis by A1, XBOOLE_0:def 8, XBOOLE_1:7;
  end;
  thus ExtNAT c< ExtINT
  proof
    -1 in INT & not -1 in NAT & not -1 in {+infty} by INT_1:def 1;
    then A2: -1 in ExtINT & not -1 in ExtNAT by XBOOLE_0:def 3;
    NAT c= INT & {+infty} c= {-infty,+infty} by NUMBERS:17, ZFMISC_1:7;
    hence thesis by A2, COUNTERS:def 1, XBOOLE_1:13, XBOOLE_0:def 8;
  end;
  thus ExtINT c< ExtREAL
  proof
    not REAL c= INT by XBOOLE_0:def 10, NUMBERS:15,25;
    then consider x being object such that
    A3: x in REAL & not x in INT
    by TARSKI:def 3; 
    not x in {-infty,+infty} by A3, TARSKI:def 2;
    then x in ExtREAL & not x in ExtINT by A3, XXREAL_0:def 4, XBOOLE_0:def 3;
    hence thesis by XBOOLE_0:def 8;
  end;
end;

registration
  cluster ExtINT -> non empty infinite;
  coherence by Th2, FINSET_1:1, XBOOLE_0:def 8;
end;

definition
  let x be object;
  attr x is ext-integer means :Def2:
  x in ExtINT;
end;

registration
  cluster +infty -> ext-integer;
  coherence
  proof
    +infty in {+infty,-infty} by TARSKI:def 2;
    hence thesis by XBOOLE_0:def 3;
  end;
  cluster -infty -> ext-integer;
  coherence
  proof
    -infty in {+infty,-infty} by TARSKI:def 2;
    hence thesis by XBOOLE_0:def 3;
  end;
  cluster ext-integer -> ext-real for object;
  coherence;
  cluster ext-natural -> ext-integer for object;
  coherence
  proof
    let x be object;
    assume x is ext-natural;
    then x in ExtNAT by COUNTERS:def 2;
    hence thesis by Th2, TARSKI:def 3, XBOOLE_0:def 8;
  end;
end;

registration
  cluster zero ext-integer for object;
  existence
  proof
    take 0;
    thus thesis;
  end;
  cluster non zero ext-integer for object;
  existence
  proof
    take 1;
    thus thesis;
  end;
  cluster ext-integer for set;
  existence
  proof
    take 0;
    thus thesis;
  end;
  cluster -> ext-integer for Element of ExtINT;
  coherence;
  cluster -> ext-integer for Element of ExtNAT;
  coherence;
end;

definition
  mode ExtInt is ext-integer ExtReal;
end;

registration
  sethood of ExtInt
  proof
    take ExtINT;
    thus thesis by Def2;
  end;
end;

theorem Th4:
  for x being object
  holds x is ExtInt iff (x is Integer or x = -infty or x = +infty)
proof
  let x be object;
  thus x is ExtInt implies (x is Integer or x = -infty or x = +infty)
  proof
    assume A1: x is ExtInt;
    assume A2: not x is Integer & not x = -infty;
    x in INT \/ {-infty, +infty} by A1, Def2;
    then x in INT or x in {-infty, +infty} by XBOOLE_0:def 3;
    hence x = +infty by A2, TARSKI:def 2;
  end;
  thus (x is Integer or x = -infty or x = +infty) implies x is ExtInt
  proof
    assume x is Integer or x = -infty or x = +infty;
    then x in INT or x in {-infty,+infty} by INT_1:def 2, TARSKI:def 2;
    then x in INT \/ {-infty,+infty} by XBOOLE_0:def 3;
    hence x is ExtInt by Def2;
  end;
end;

registration
  cluster zero -> ext-integer for object;
  coherence;
  cluster integer -> ext-integer for object;
  coherence by Th4;
end;

registration
  cluster natural -> ext-integer for object;
  coherence;
end;

registration
  cluster positive for ExtInt;
  existence
  proof
    take 1;
    thus thesis;
  end;
  cluster non positive for ExtInt;
  existence
  proof
    take -1;
    thus thesis;
  end;
  cluster negative for ExtInt;
  existence
  proof
    take -1;
    thus thesis;
  end;
  cluster non negative for ExtInt;
  existence
  proof
    take 1;
    thus thesis;
  end;
end;

registration
  let m be ExtInt;
  cluster - m -> ext-integer;
  coherence
  proof
    per cases by Th4;
    suppose m is Integer;
      then reconsider M=m as Integer;
      -M is Integer;
      hence thesis by XXREAL_3:def 3;
    end;
    suppose m=-infty;
      hence thesis by XXREAL_3:def 3;
    end;
    suppose m=+infty;
      hence thesis by XXREAL_3:def 3;
    end;
  end;
end;

registration
  let m, n be ExtInt;
  cluster min(m, n) -> ext-integer;
  coherence by XXREAL_0:def 9;
  cluster max(m, n) -> ext-integer;
  coherence by XXREAL_0:def 10;
  cluster m + n -> ext-integer;
  coherence
  proof
    per cases by Th4;
    suppose A1: m is Integer;
      then reconsider M=m as Integer;
      per cases by Th4;
      suppose n is Integer;
        then reconsider N=n as Integer;
        M + N is Integer;
        hence thesis by XXREAL_3:def 2;
      end;
      suppose n=-infty;
        hence thesis by A1, XXREAL_3:def 2;
      end;
      suppose n=+infty;
        hence thesis by A1, XXREAL_3:def 2;
      end;
    end;
    suppose A2: m=-infty;
      per cases by Th4;
      suppose n is Integer;
        hence thesis by A2, XXREAL_3:def 2;
      end;
      suppose n=-infty;
        hence thesis by A2, XXREAL_3:def 2;
      end;
      suppose n=+infty;
        hence thesis by A2;
      end;
    end;
    suppose A3: m=+infty;
      per cases by Th4;
      suppose n is Integer;
        hence thesis by A3, XXREAL_3:def 2;
      end;
      suppose n=-infty;
        hence thesis by A3;
      end;
      suppose n=+infty;
        hence thesis by A3;
      end;
    end;
  end;
  cluster m * n -> ext-integer;
  coherence
  proof
    per cases by Th4;
    suppose m is Integer;
      then reconsider M=m as Integer;
      per cases by Th4;
      suppose n is Integer;
        then reconsider N=n as Integer;
        M * N is Integer;
        hence thesis by XXREAL_3:def 5;
      end;
      suppose B1: n=-infty;
        m is positive or m is negative or m is zero;
        hence thesis by B1, XXREAL_3:def 5;
      end;
      suppose B2: n=+infty;
        m is positive or m is negative or m is zero;
        hence thesis by B2, XXREAL_3:def 5;
      end;
    end;
    suppose A2: m=-infty;
      per cases by Th4;
      suppose n is Integer;
        n is positive or n is negative or n is zero;
        hence thesis by A2, XXREAL_3:def 5;
      end;
      suppose n=-infty;
        hence thesis by A2, XXREAL_3:def 5;
      end;
      suppose n=+infty;
        hence thesis by A2, XXREAL_3:def 5;
      end;
    end;
    suppose A3: m=+infty;
      per cases by Th4;
      suppose n is Integer;
        n is positive or n is negative or n is zero;
        hence thesis by A3, XXREAL_3:def 5;
      end;
      suppose n=-infty;
        hence thesis by A3, XXREAL_3:def 5;
      end;
      suppose n=+infty;
        hence thesis by A3;
      end;
    end;
  end;
end;

registration
  let m, n be ExtInt;
  cluster m - n -> ext-integer;
  coherence
  proof
    (- n) is ext-integer & m + (- n) is ext-integer &
    m - n = m + (- n) by XXREAL_3:def 4;
    hence thesis;
  end;
end;

registration
  cluster non negative -> ext-natural for ExtInt;
  coherence
  proof
    let x be ExtInt;
    assume A1: x is non negative;
    x is Integer or x = -infty or x = +infty by Th4;
    hence thesis by A1;
  end;
end;

theorem ThPosExtInt:
  for x being object
  holds x is positive ExtInt iff (x is positive Integer or x = +infty) by Th4;

theorem ThNegExtInt:
  for x being object
  holds x is negative ExtInt iff (x is negative Integer or x = -infty) by Th4;


begin :: 3. Floating-point formats

definition
  func -0 -> object equals [0,0];
  coherence;
end;

theorem Th4:
  for n being Nat
  holds [n,0] <> +infty & [n,0] <> -infty
proof
  let n be Nat;
  A1: n in REAL by NUMBERS:19, TARSKI:def 3, ORDINAL1:def 12;
  +infty = [n,0] implies contradiction
  proof
    assume A2: +infty = [n,0];
    then +infty = {{n}, {n,0}} by TARSKI:def 5;
    then n = {n} or n = {n,0};
    then per cases;
    suppose n = {n};
      hence contradiction by ZFMISC_1:140;
    end;
    suppose n = {n,0};
      then n in n or n in 0 by TARSKI:def 2;
      hence contradiction by ORDINAL1:def 13;
    end;
  end;
  hence [n,0] <> +infty;
  thus [n,0] <> -infty by A1, XXREAL_0:def 3, XTUPLE_0:1, ORDINAL1:def 13;
end;

theorem Th5:
  not -0 in ExtREAL
proof
  [0,0] <> +infty & [0,0] <> -infty by Th4;
  then not (-0 in REAL or -0 in {+infty, -infty})
  by NUMBERS:def 1, ZFMISC_1:56, TARSKI:def 2;
  hence thesis by NUMBERS:def 5, XBOOLE_0:def 3, XXREAL_0:def 2,def 3;
end;

Lm1:
  for n being Nat
  holds not [n,0] in RAT+
proof
  let n be Nat;
  assume A1: [n,0] in RAT+;
  n in omega by ORDINAL1:def 12;
  then 0 <> {} by A1, ARYTM_3:33;
  hence contradiction by ORDINAL1:def 13;
end;

Lm2:
  for a,b being Nat
  st a = {b}
  holds b = {}
proof
  let a,b be Nat;
  assume A1: a = {b};
  then consider c being Nat such that
  A2: a = succ c by CARD_1:36;
  {b} = c \/ {c} by A1, A2, ORDINAL1:def 1;
  then c = {} by ZFMISC_1:38, ZFMISC_1:140;
  then a = {} \/ {{}} by A2, ORDINAL1:def 1;
  hence thesis by A1, ZFMISC_1:3;
end;

Lm3:
  for i being Nat st i <> 0
  holds not {i} in RAT+
proof
  let i be Nat such that
  A1: i <> 0;
  assume A2: {i} in RAT+;
  then per cases by ARYTM_3:29;
  suppose {i} in omega;
    then {} in {i} by ORDINAL3:8;
    hence contradiction by A1, ORDINAL1:def 13, TARSKI:def 1;
  end;
  suppose ex a,b being Element of omega st ({i} = [a,b] &
    a,b are_coprime & b <> {} & b <> 1);
    then consider a,b being Element of omega such that
    A3: ({i} = [a,b] & a,b are_coprime & b <> {} & b <> 1);
    {i} = {{a}, {a,b}} by A3, TARSKI:def 5;
    then {a} = {a,b} by ZFMISC_1:5;
    then A4: a = b by ZFMISC_1:5;
    then {i} = {{b}, {b,b}} by A3, TARSKI:def 5
            .= {{b}, {b}} by ENUMSET1:29
            .= {{b}} by ENUMSET1:29;
    hence contradiction by A3, Lm2, ZFMISC_1:3;
  end;
end;

Lm4:
  for i being Nat st i <> 0
  holds not [i,0] in DEDEKIND_CUTS
proof
  let i be Nat such that
  A1: i <> 0;
  assume [i,0] in DEDEKIND_CUTS;
  then [i,0] in {A where A is Subset of RAT+ : for r being Element of RAT+
  st r in A holds ((for s being Element of RAT+ st s <=' r holds s in A)
                   & ex s being Element of RAT+ st (s in A & r < s)) }
  by ARYTM_2:def 1;
  then consider A being Subset of RAT+ such that
  A2: [i,0] = A
    & for r being Element of RAT+ st r in A
      holds (for s being Element of RAT+ st s <=' r holds s in A)
          & ex s being Element of RAT+ st s in A & r < s;
  A = {{i}, {i,0}} by A2, TARSKI:def 5;
  then {i} in RAT+ & {i,0} in RAT+ by ZFMISC_1:32;
  hence contradiction by A1, Lm3;
end;

theorem Th6:
  for i being Nat
  holds not [i,0] in ExtREAL
proof
  let i be Nat;
  A1: not [i,0] in REAL
  proof
    per cases;
    suppose i = 0;
      hence thesis by Th5, NUMBERS:def 5, XBOOLE_0:def 3;
    end;
    suppose A1: i <> 0;
      then not ([i,0] in RAT+ or [i,0] in DEDEKIND_CUTS) by Lm1,Lm4;
      then A2: not [i,0] in REAL+ by ARYTM_2:def 2, XBOOLE_0:def 3;
      not [i,0] in [:{0},REAL+:] by A1, ZFMISC_1:105;
      hence thesis by A2, XBOOLE_0:def 3, NUMBERS:def 1;
    end;
  end;
  [i,0] <> +infty & [i,0] <> -infty by Th4;
  then not [i,0] in {+infty,-infty} by TARSKI:def 2;
  then not [i,0] in REAL \/ {+infty,-infty} by A1, XBOOLE_0:def 3;
  hence not [i,0] in ExtREAL by NUMBERS:def 5, XXREAL_0:def 2,def 3;
end;

definition
  func NaN -> object equals [1,0];
  coherence;
end;

theorem
  not NaN in ExtREAL by Th6;

reserve beta for valid_radix Real;
reserve p for positive Integer;
reserve eMin for negative ExtInt;
reserve eMax for positive ExtNat;

definition
  let b, p, eMin, eMax;
  func FLOAT_NUMBER(b, p, eMin, eMax) -> Subset of ExtREAL equals
  {x where x is Real : ex M, e being Integer
   st x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
   & eMin - 1 < e & e <= eMax } \/ {+infty, -infty};
  coherence
  proof
    set NUM = {x where x is Real : ex M, e being Integer
    st x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
    & eMin - 1 < e & e <= eMax };
    set IT = NUM \/ {+infty, -infty};
    for x being object st x in IT holds x in ExtREAL
    proof
      let x be object;
      assume Z1: x in IT;
      then per cases by XBOOLE_0:def 3;
      suppose A1: x in NUM;
        then ex y being Real st x = y & ex M, e being Integer
        st y = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
        & eMin - 1 < e & e <= eMax;
        then x in REAL by XREAL_0:def 1;
        hence x in ExtREAL by XBOOLE_0:def 3, XXREAL_0:def 4;
      end;
      suppose A2: x in {-infty, +infty};
        hence x in ExtREAL by XBOOLE_0:def 3, XXREAL_0:def 4;
      end;
    end;
    hence thesis by TARSKI:def 3;
  end;
end;

theorem St3200:
  -infty in FLOAT_NUMBER(b, p, eMin, eMax)
  & +infty in FLOAT_NUMBER(b, p, eMin, eMax)
proof
  -infty in {-infty,+infty} by TARSKI:def 2;
  hence -infty in FLOAT_NUMBER(b, p, eMin, eMax) by XBOOLE_0:def 3;
  +infty in {-infty,+infty} by TARSKI:def 2;
  hence +infty in FLOAT_NUMBER(b, p, eMin, eMax) by XBOOLE_0:def 3;
end;

theorem Th11:
  for x being Real
  holds x in FLOAT_NUMBER(b, p, eMin, eMax) iff
  (ex M, e being Integer
  st x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
  & eMin - 1 < e & e <= eMax)
proof
  set NUM = {x where x is Real : ex M, e being Integer
   st x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
   & eMin - 1 < e & e <= eMax };
  let x be Real;
  thus x in FLOAT_NUMBER(b, p, eMin, eMax) implies
  (ex M, e being Integer
  st x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
  & eMin - 1 < e & e <= eMax)
  proof
    assume A1: x in FLOAT_NUMBER(b, p, eMin, eMax);
    then x in NUM or x in {+infty, -infty} by XBOOLE_0:def 3;
    then ex y being Real st x = y & ex M, e being Integer
    st y = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
    & eMin - 1 < e & e <= eMax by TARSKI:def 2;
    hence thesis;
  end;
  thus (ex M, e being Integer
  st x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
  & eMin - 1 < e & e <= eMax) implies x in FLOAT_NUMBER(b, p, eMin, eMax)
  proof
    given M, e being Integer such that 
    A1: x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
    & eMin - 1 < e & e <= eMax;
    x in NUM by A1;
    hence x in FLOAT_NUMBER(b, p, eMin, eMax) by XBOOLE_0:def 3;
  end;
end;

Lm7:
  for y being ExtReal st y in REAL
  holds y in FLOAT_NUMBER(b, p, eMin, eMax)
  implies (- y) in FLOAT_NUMBER(b, p, eMin, eMax)
proof
  let y be ExtReal;
  assume A2: y in REAL;
  assume y in FLOAT_NUMBER(b, p, eMin, eMax);
  then consider M, e being Integer such that
  A3: y = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
  & eMin - 1 < e & e <= eMax
  by A2, Th11;
  A4: (- M) * (b to_power (e - p + 1))
  = - (M * (b to_power (e - p + 1)))
  .= (-1) * ((M * (b to_power (e - p + 1))) qua ExtReal)
  .= (-1) * (y) by A3
  .= - y by XXREAL_3:91;
  |.(- M).| = |.M.| by COMPLEX1:52;
  hence (- y) in FLOAT_NUMBER(b, p, eMin, eMax) by A3,A4,Th11;
end;

theorem
  for x being ExtReal
  holds x in FLOAT_NUMBER(b, p, eMin, eMax)
  iff (- x) in FLOAT_NUMBER(b, p, eMin, eMax)
proof
  let x be ExtReal;
  A1: - -infty = +infty & - +infty = -infty by XXREAL_3:def 3;
  x in REAL \/ {+infty, -infty} by XXREAL_0:def 1,def 4;
  then x in REAL or x in {+infty, -infty} by XBOOLE_0:def 3;
  then per cases by TARSKI:def 2;
  suppose CASE1: x in REAL;
    thus x in FLOAT_NUMBER(b, p, eMin, eMax)
    implies (- x) in FLOAT_NUMBER(b, p, eMin, eMax) by CASE1,Lm7;
  
    A2: - x in REAL by CASE1, XREAL_0:def 1;
    assume (- x) in FLOAT_NUMBER(b, p, eMin, eMax);
    then - (- x) = x & - (- x) in FLOAT_NUMBER(b, p, eMin, eMax) by Lm7,A2;
    hence x in FLOAT_NUMBER(b, p, eMin, eMax);
    hence thesis by Lm7;
  end;
  suppose CASE2: x=+infty;
    hence thesis by A1, CASE2, St3200;
  end;
  suppose CASE3: x=-infty;
    hence thesis by A1, CASE3, St3200;
  end;
end;

theorem Th12:
  for x being positive Real
  holds x in FLOAT_NUMBER(b, p, eMin, eMax) iff
  (ex M, e being Integer
  st x = M * (b to_power (e - p + 1)) & 0 < M & M <= b to_power (p-1)
  & eMin - 1 < e & e <= eMax)
proof
  let x be positive Real;
  thus x in FLOAT_NUMBER(b, p, eMin, eMax) implies (ex M, e being Integer
  st x = M * (b to_power (e - p + 1)) & 0 < M & M <= b to_power (p-1)
  & eMin - 1 < e & e <= eMax)
  proof
    assume x in FLOAT_NUMBER(b, p, eMin, eMax);
    then consider M, e being Integer such that
    A1: x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
    & eMin - 1 < e & e <= eMax by Th11;
    take M, e;
    thus thesis by A1, COMPLEX1:43;
  end;
  given M, e being Integer such that 
  A2: x = M * (b to_power (e - p + 1)) & 0 < M & M <= b to_power (p-1) & eMin - 1 < e & e <= eMax;
  |.M.| = M by A2, COMPLEX1:43;
  hence thesis by A2, Th11;
end;

definition
  let beta, p, eMin, eMax;
  func FLOAT(beta, p, eMin, eMax) -> set equals
  FLOAT_NUMBER(beta, p, eMin, eMax) \/ {-0, NaN};
  coherence;
end;

theorem St3300:
  for eMin being negative Integer
  for x being ExtReal
  st x in FLOAT_NUMBER(b, p, eMin, eMax)
   & x > 0
   holds b to_power (eMin - p + 1) <= x
proof
  let eMin be negative Integer;
  let x be ExtReal;
  assume A1: x in FLOAT_NUMBER(b, p, eMin, eMax);
  assume A2: x > 0;
  x in REAL \/ {+infty,-infty} by XXREAL_0:def 1,def 4;
  then x in REAL or x in {+infty,-infty} by XBOOLE_0:def 3;
  then per cases by TARSKI:def 2;
  suppose x in REAL;
    then reconsider X=x as positive Real by A2;
    consider M, e being Integer such that
    A3: X = M * (b to_power (e - p + 1)) & 0 < M & M <= b to_power (p-1)
    & eMin - 1 < e & e <= eMax by A1, Th12;
    eMin - 1 + 1 <= e by A3, INT_1:7;
    then eMin + (1 - p) <= e + (1 - p) by XREAL_1:6;
    then A4: (b to_power (eMin - p + 1)) <= (b to_power (e - p + 1))
    by Def1, Th1;
    0 + 1 <= M by A3, INT_1:7;
    then 1 * (b to_power (e - p + 1)) <= M * (b to_power (e - p + 1))
    by XREAL_1:64;
    hence (b to_power (eMin - p + 1)) <= x by A3, A4, XXREAL_0:2;
  end;
  suppose x=+infty;
    hence b to_power (eMin - p + 1) <= x by XREAL_0:def 1, XXREAL_0:9;
  end;
  suppose x=-infty;
    hence thesis by A2;
  end;
end;

theorem St3301:
  for eMin being negative Integer
  for x being Real
  st x in FLOAT_NUMBER(b, p, eMin, eMax) & b in INT
  ex n being Integer
  st n*(b to_power (eMin - p + 1)) = x
proof
  let eMin be negative Integer;
  let x be Real;
  assume A1: x in FLOAT_NUMBER(b, p, eMin, eMax);
  assume b in INT;
  then A2: b in NAT by INT_1:3;
  consider M, e being Integer such that
  A3: x = M * (b to_power (e - p + 1)) & |.M.| <= b to_power (p-1)
  & eMin - 1 < e & e <= eMax by A1,Th11;
  (eMin - 1) + 1 <= e by A3, INT_1:7;
  then eMin - eMin <= e - eMin by XREAL_1:9;
  then e - eMin in NAT by INT_1:3;
  then b to_power (e - eMin) in NAT by A2, ThNatPowers;
  then reconsider n = M * (b to_power (e - eMin)) as Integer;
  take n;
  thus n*(b to_power (eMin - p + 1))
   = (M * (b to_power (e - eMin))) * (b to_power (eMin - p + 1))
  .= M * ((b to_power (e - eMin)) * (b to_power (eMin - p + 1)))
  .= M * (b to_power ((e - eMin) + (eMin - p + 1))) by POWER:27
  .= M * (b to_power (e - p + 1))
  .= x by A3;
end;

definition
  let b, p, eMin, eMax;
  let IT be Element of FLOAT(b,p,eMin,eMax);
  attr IT is normal means :Def8:
  IT <> 0 if eMin =-infty,
  ex iMin being negative Integer st iMin = eMin
  & ex x being Real st x = IT
  & b to_power iMin <= |.x.| if eMin <> -infty & eMax = +infty
  otherwise ex iMin being negative Integer st iMin = eMin
  & ex iMax being positive Integer st iMax = eMax
  & ex x being Real st x = IT
  & b to_power iMin <= |.x.|
  & |.x.| <= (b to_power iMax)*(b - (b to_power (1 - p)));
  consistency;
end;

Lm19:
  b to_power (1 - p) <= 1
  & 1 <= b to_power (p - 1)
proof
  A1: p >= 0 + 1 by INT_1:7;
  then 1 - p <= 1 - 1 by XREAL_1:13;
  then b to_power (1 - p) <= b to_power 0 by Def1,Th1;
  hence b to_power (1 - p) <= 1 by POWER:24;
  1 - 1 <= p - 1 by A1, XREAL_1:9;
  then b to_power 0 <= b to_power (p - 1) by Def1,Th1;
  hence 1 <= b to_power (p - 1) by POWER:24;
end;

Lm20:
  for eMax being positive Integer
  holds b <= b to_power eMax
proof
  let eMax be positive Integer;
  0 + 1 <= eMax by INT_1:7;
  then b to_power 1 <= b to_power eMax by Def1,Th1;
  hence b <= b to_power eMax by POWER:25;
end;

Lm21:
  for eMax being positive Integer
  holds b * (b - 1) <= (b to_power eMax)*(b - (b to_power (1 - p)))
proof
  let eMax be positive Integer;
  A1: 0 <= b - 1 & 0 <= b
  proof
    b > 1 by Def1;
    hence 0 <= b - 1 by XREAL_1:48;
    thus 0 <= b;
  end;
  1 >= b to_power (1 - p) by Lm19;
  then A2: b - 1 <= b - (b to_power (1 - p)) by XREAL_1:13;
  b <= b to_power eMax by Lm20;
  hence b * (b - 1) <= (b to_power eMax)*(b - (b to_power (1 - p)))
  by A1, A2, XREAL_1:66;
end;

theorem ThNormalFloatInNegInfty:
  for x being Element of FLOAT(b, p, eMin, eMax)
  st x=1 & eMin=-infty
  holds x is normal
proof
  let x be Element of FLOAT(b, p, eMin, eMax);
  assume A1: x=1;
  assume eMin=-infty;
  hence x is normal by A1,Def8;
end;

theorem
  for x being Element of FLOAT(b, p, eMin, eMax)
  st x=1 & eMax=+infty
  holds x is normal
proof
  let x be Element of FLOAT(b, p, eMin, eMax);
  assume A1: x=1;
  assume A2: eMax=+infty;
  per cases;
  suppose eMin=-infty;
    hence thesis by ThNormalFloatInNegInfty,A1;
  end;
  suppose A3: eMin <> -infty;
    then reconsider iMin = eMin as negative Integer by ThNegExtInt;
    reconsider x1=x as Real by A1;
    b > 1 by Def1;
    then b to_power iMin < |.x1.| by A1,COMPLEX1:48,POWER:36;
    hence x is normal by A2,Def8;
  end;
end;

definition
  let b, p, eMin, eMax;
  let IT be Element of FLOAT(b,p,eMin,eMax);
  attr IT is subnormal means
  ex x being Real st x = IT &
  ex iMin being negative Integer st iMin = eMin
  & 0 < |.x.| & |.x.| < b to_power iMin;
end;
