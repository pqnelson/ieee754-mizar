% -*- mode: poly-noweb; noweb-code-mode: mizar-mode; -*-
\section{Floating-Point Formats}

<<3. Floating-point formats>>=
begin :: 3. Floating-point formats

<<Reserve: parameters for floating-point format>>

<<Theorem: value of maximum mantissa>>

<<Definition: subset of floating-point numbers for a format>>

<<Theorem: if $b\in\NN$, then $(\lceil b\rceil-1))(b^{p}-1)/(b-1)=(b^{p}-1)$>>

<<Definition: [[FLOAT_NUMBER]] over integer radix>>

<<Theorem: If $n<x\leq n+1$, then $\lceil x\rceil=n+1$>>

<<Theorem: $0\leq\bigl((\lceil\beta\rceil-1)/(\beta-1)\bigr)(\beta^{p}-1)$>>

<<Theorem: zero is a floating-point number>>

<<Register: [[FLOAT_NUMBER]] is non empty>>

<<Register: real for [[FLOAT_NUMBER]] and they're all extended reals>>

<<Theorem: infinity is a float-poing number>>

<<Theorem: criteria for real numbers to be exact floating-point numbers>>

<<Theorem: criterion for floating-point numbers over integer radix>>

<<Lemma: if $y$ is floating-point number, then $-y$ is a floating-point number>>

<<Theorem: floating-point numbers closed under negation>>

<<Theorem: finite real numbers are floating-point numbers iff their negation are floating-point numbers>>

<<Theorem: criteria for positive real numbers to be exact floating-point numbers>>

<<Theorem: if $b$ is a natural number, then $1\in\FF(b,p,e_{\text{min}},e_{\text{max}})$>>

<<Definition: floating-point format as [[FLOAT]]>>

<<Definition: attribute $(\beta,p,e_{\text{min}},e_{\text{max}})$-format floating-point>>

<<Register: [[(beta, p, eMin, eMax)-format_floating-point]] for number>>

<<Definition: [[Float]] for floating-point format Number>>

<<Register: sethood of [[Float]]>>

<<Theorem: Zero is a Float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$>>

<<Register: [[ext-real]] and [[real]] for [[Float]]>>

<<Register: [[zero]] and [[non zero]] for [[Float]]>>

<<Theorem: $\pm\infty$ is a float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$>>

<<Definition: [[positive]] and [[negative]] for [[Float]]>>

<<Register: positive and negative Floats are extended-reals>>

<<Register: positive, negative, non-positive, non-negative Floats>>

<<Theorem: negative Floats are less than zero>>

<<Theorem: positive Floats are greater than zero>>

<<Theorem: extended-real [[Float]] are elements of [[FLOAT_NUMBER]]>>

<<Theorem: smallest [positive] Float of format $b$, $p$, $e_{\text{min}}$, $e_{\text{max}}$>>

<<Theorem: positive Floats are either real or $+\infty$>>

<<Theorem: negative Floats are either real or $-\infty$>>

<<Theorem: floating-point numbers are integer multiples of $\beta^{e_{\text{min}}-p+1}$>>

<<Corollary: the smallest positive floating-point number is $b^{e_{\text{min}}-p+1}$>>

<<Corollary: Smallest negative floating-point number>>

<<Definition: normal floating-point number>>

<<Register: normal implies real for floating-point numbers>>

<<Theorem: criterion for normal floating-point numbers with $e_{\text{min}}\in\ZZ$ and $e_{\text{max}}\in\ZZ$>>

<<Lemma: $b^{1-p}\leq1$ and $1\leq b^{p-1}$>>

<<Lemma: $b\leq b^{e_{\text{max}}}$>>

<<Lemma: $b(b-1)\leq b^{e_{\text{max}}}(b-b^{1-p})$>>

<<Theorem: If $1\in\FF(\beta,p,-\infty,e_{\text{max}})$, then 1 is normal>>

<<Theorem: If $1\in\FF(\beta,p,e_{\text{min}},+\infty)$, then 1 is normal>>

<<Theorem: If $b\in\NN$, then there exists a normal floating-point number>>

<<Register: normal floating-point datum>>

<<Definition: subnormal floating-point datum>>

<<Register: every subnormal floating-point number is real>>

<<Theorem: floating-point numbers are real floating-point format data>>

<<Theorem: $e_{\text{min}}\in\ZZ$, $b\in\NN$, $p=1$ implies there is no subnormal floating-point numbers>>

<<Theorem: there is no subnormal element of $\FF(\beta,p,-\infty,e_{\text{max}})$>>

<<Theorem: 0 is neither normal nor subnormal>>

<<Register: zero, normal, subnormal floats are disjoint>>

<<Theorem: if $p>1$, then $b^{e_{\text{min}}+1-p}$ is subnormal>>

<<Theorem: Existence of subnormal float for $b\in\NN$, $e_{\text{min}}\in\ZZ$, and $p>1$>>

<<Register: existence of subnormal floating-point numbers>>

<<Definition: basic floating-point formats>>
@ 

\subsection{Overview}
The basic idea is that we have a ``floating-point format'', which
``represent'' a finite subset of the extended reals adjoined with a
special [[NaN]] symbol. The standard explicitly states that ``Formats
are characterized by their radix, precision, and exponent range'' and
each format can represent a unique set of ``floating-point data''.

Do not be confused: a floating-point format is uniquely identified by
its tuple of parameters $(\beta,p,e_{\text{min}}, e_{\text{max}})$
\emph{but} it refers a set of ``floating-point data'' [i.e., a finite
subset of the extended reals $\ExtRR$ equipped with the symbol
\texttt{NaN} and adjoined with a ``signed zero'' $-0$ treated as a
numeric].

This is then in contrast to a ``representation'' of floating-point data,
which is the set of triples $(s,e,m)\in\{0,1\}\times\ZZ\times\NN$ within
the specified range, unioned with the signed infinities and both the
quiet and signaling NaN constants.

When we have some floating-point format $F(\beta,p,e_{\text{min}}, e_{\text{max}})$ given, we use a
\emph{rounding function} $R\colon\ExtRR\to F(\beta,p,e_{\text{min}}, e_{\text{max}})$ to map extended real
numbers to floating-point numbers. This $R$ is surjective on
$F(\beta,p,e_{\text{min}}, e_{\text{max}})\setminus\{\mathtt{NaN},-0\}$, $R$ must be monotonic, and preserves
zero $R(0)=+0$ and infinities. There are multiple possible rounding
functions, the IEEE-754 standard gives us 5 possibilities. These
rounding functions parametrize the elementary arithmetic operators
$\star_{R}\colon F\times F\to F$ where
$\star\in\{+,-,\times,\div,\sqrt{\enspace}\}$. But we are getting ahead
of ourselves.

\subsection{Specification Levels}

\begin{reserve}
We will reserve $\beta$ for some positive real number [to work in
as maximal generality as convenient],
$p$ for some positive natural number,
$e_{\text{min}}$ for a negative integer (possibly equal to $-\infty$),
$e_{\text{max}}$ for a positive integer or $+\infty$.
\end{reserve}

<<Reserve: parameters for floating-point format>>=
reserve beta for positive Real;
reserve p for positive Nat;
reserve eMin for negative ExtInt;
reserve eMax for positive ExtNat;
@

\begin{theorem}
Let $d$ be a finite sequence of natural numbers.
Suppose the length of $d$ is equal to $p$.
If for each $i=0,1,\dots,p-1$ we have $0\leq d_{i}<(\lceil\beta\rceil-1)\beta^{-i}$,
then
\begin{equation*}
\sum_{j=0}^{p-1}d_{j}<\frac{\lceil\beta\rceil-1}{\beta-1}(\beta-\beta^{1-p}).
\end{equation*}
\end{theorem}

We should really think of the sequence $d$ as the digits in the
expansion $d_{0}\bullet d_{1}d_{2}\cdots d_{p-1}$ in base $\beta>1$. The
largest value of each digit is $\lceil\beta\rceil-1$, and then we obtain
a geometric sum for the maximum value. This is important, because the
Standard assumes $\beta=2$ or $\beta=10$, but if we want to explore the
design space we should figure out what happens for positive $\beta\in\RR$?

\begin{proof}[Proof sketch]
Set $\kappa_{0} = \lceil\beta\rceil-1$.
We construct the sequence $c_{j}=\kappa_{0}\beta^{-j}$ for $j=0,\dots,p-1$.
We then prove $(A_{5})$ that $\sum_{j}c_{j}=(\kappa_{0}/(\beta-1))(\beta-\beta^{1-p})$,
and since $(A_{6})$ the lengths of $d$ and $c$ are equal and $d_{j}<c_{j}$ for each $j$, it follows that $\sum d\leq\sum c$,
and the result follows.
\end{proof}

<<Theorem: value of maximum mantissa>>=
theorem ThMaxMantissaValue:
  for d being XFinSequence of NAT
  st len d = p
  & (for i being Nat st i in dom d
     holds 0 <= d.i & d.i <= ([/beta\] - 1) * (beta to_power - i))
  & beta <> 1
  holds Sum d <= (([/beta\]-1)/(beta - 1))*(beta - (beta to_power (1 - p)))
proof
  let d be XFinSequence of NAT;
  assume A1: len d = p;
  assume A2: for i being Nat st i in dom d
             holds 0 <= d.i & d.i <= ([/beta\] - 1) * (beta to_power - i);
  assume A3: beta <> 1;
  set k0 = [/beta\] - 1;
  set c = (k0 (#) ((beta ") GeoSeq))|p;
  A4: dom c = p
  proof
    B1: dom (k0 (#) ((beta ") GeoSeq)) = NAT by FUNCT_2:def 1;
    p is Ordinal & p in omega by ORDINAL1:def 12;
    then for z being Ordinal st z in p
    holds z in omega by ORDINAL1:10;
    hence dom ((k0 (#) ((beta ") GeoSeq))|p) = p
    by B1, RELAT_1:62, ORDINAL1:def 5;
  end;
  then reconsider c as XFinSequence by AFINSQ_1:5;
  reconsider c as XFinSequence of REAL;
  
  A5: Sum c = (k0/(beta - 1)) * (beta - (beta to_power (1 - p)))
  proof
    consider n being Nat such that
    B1: p = n+1
    by NAT_1:6;
    B2: n = p - 1 by B1;
    1" = 1; then
    B3: beta" <> 1 by A3;
    thus Sum c
    = (Partial_Sums (k0 (#) ((beta ") GeoSeq))).n by B1,AFINSQ_2:56
    .= (k0 (#) (Partial_Sums ((beta ") GeoSeq))).n by SERIES_1:9
    .= k0 * ((Partial_Sums ((beta ") GeoSeq)).n) by SEQ_1:9
    .= k0 * ((1 - ((beta ") to_power (n + 1)))/(1 - (beta "))) by B3,SERIES_1:22
    .= k0 * ((1 - ((1 * (beta ")) to_power p))/(1 - (1 / beta))) by B1,XCMPLX_1:215
    .= k0 * (1 * ((1 - ((1/beta) to_power p))/(1 - (1 / beta)))) by XCMPLX_1:215
    .= k0 * ((beta/beta) * ((1 - ((1/beta) to_power p))/(1 - (1 / beta))))
    by XCMPLX_1:60
    .= k0 * ((beta * (1 - ((1/beta) to_power p)))/(beta * (1 - (1 / beta))))
    by XCMPLX_1:76
    .= k0 * (((beta * 1) - (beta * ((1/beta) to_power p)))/(beta * 1 - beta*(1/beta)))
    .= k0 * ((beta - (beta * ((1/beta) to_power p)))/(beta - 1))
    by XCMPLX_1:106
    .= k0 * ((beta - ((beta to_power 1) * (beta to_power -p)))/(beta - 1))
    by POWER:32
    .= k0 * ((beta - (beta to_power (1 + (-p))))/(beta - 1)) by POWER:27
    .= (k0/(beta - 1)) * (beta - (beta to_power (1 - p))) by XCMPLX_1:75;
  end;

  A6: len c = len d by A1,A4;
  for i being Nat st i in dom d holds d.i <= c.i
  proof
    let i be Nat;
    assume B1: i in dom d;
    B2: i in dom c by A6,B1;
    then i in p by A4; then
    c.i = (k0 (#) ((beta ") GeoSeq)).i by FUNCT_1:49
       .= k0 * (((beta ") GeoSeq).i) by SEQ_1:9
       .= k0 * ((beta ") to_power i) by PREPOWER:def 1
       .= k0 * ((1 / beta) to_power i) by XCMPLX_1:215
       .= k0 * (beta to_power -i) by POWER:32;
    hence d.i <= c.i by A2, B1;
  end;
  then Sum d <= Sum c by A6, AFINSQ_2:57;
  hence thesis by A5;
end;
@ %def ThMaxMantissaValue

\begin{definition}
Let $\beta$ be a positive real number, let $p$ be a natural number,
let $e_{\text{min}}\in\ZZ\cup\{-\infty\}$ and
$e_{\text{max}}\in\NN\cup\{+\infty\}$ be negative and positive integers
or infinities.
We define the set of \define{Floating-Point Numbers} to be the subset
$\FF_{n}(\beta,p,e_{\text{min}},e_{\text{max}})$ of $\ExtRR$ equal to
$\{x\in\RR \mid \exists M\in\ZZ_{\beta}\,\exists e\in\ZZ, x=M\cdot \beta^{e-p+1}\land
|M|\leq \frac{\lceil\beta\rceil-1}{\beta-1}(\beta^{p}-1)\land e_{\text{min}}-1<e\leq e_{\text{max}}\}\cup\{\pm\infty\}$.
\end{definition}

\begin{def-remark}
We should really have the set be
$\{x\in\RR \mid \exists M,e\in\ZZ, x=M\cdot \beta^{e-p+1}\land
|M|\leq\beta^{p}-1\land e_{\text{min}}\leq e\leq e_{\text{max}}\}\cup\{\pm\infty\}$
if we were trying to \emph{literally} formalize the Standard, but we are
trying to be suitably general here. We will show that this is equivalent
to the definition we offer when $\beta\in\NN$ is a valid-radix.
\end{def-remark}

We're allowing the exponents to possible be infinite because other users
of our formalization may wish to prove results using, e.g., Trefethan
and Bau's ``idealized floating-point arithmetic'' which has
$e_{\text{min}}=-\infty$ and $e_{\text{max}}=+\infty$.

We should adhere to Mizar's naming conventions, and use
[[SCREAMING_SNAKE_CASE]] when defining new sets of numbers. After all,
we're really defining the set of floating-point numbers here. We will
use the identifier [[FLOAT]] for the floating-point format, and
[[Float]] for elements of [[FLOAT]]. We are currently going to define
the set [[FLOAT_NUMBER]] as a subset of the extended reals.

<<Definition: subset of floating-point numbers for a format>>=
definition
  let beta, p, eMin, eMax;
  func FLOAT_NUMBER(beta, p, eMin, eMax) -> Subset of ExtREAL equals
  {x where x is Real : ex M being Element of beta-radix_INT, e being Integer
   st x = M * (beta to_power (e - p + 1))
   & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
   & eMin - 1 < e & e <= eMax } \/ {+infty, -infty};
  coherence
  proof
    set NUM = {x where x is Real :
    ex M being Element of beta-radix_INT, e being Integer
    st x = M * (beta to_power (e - p + 1))
    & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
    & eMin - 1 < e & e <= eMax };
    set IT = NUM \/ {+infty, -infty};
    for x being object st x in IT holds x in ExtREAL
    proof
      let x be object;
      assume Z1: x in IT;
      then per cases by XBOOLE_0:def 3;
      suppose A1: x in NUM;
        then ex y being Real st x = y
        & ex M being Element of beta-radix_INT, e being Integer
        st y = M * (beta to_power (e - p + 1))
        & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
        & eMin - 1 < e & e <= eMax;
        then x in REAL by XREAL_0:def 1;
        hence x in ExtREAL by XBOOLE_0:def 3, XXREAL_0:def 4;
      end;
      suppose A2: x in {+infty, -infty};
        hence x in ExtREAL by XBOOLE_0:def 3, XXREAL_0:def 4;
      end;
    end;
    hence thesis by TARSKI:def 3;
  end;
end;
@ %def FLOAT_NUMBER

\begin{theorem}
When $b\in\NN$, we see $(\lceil b\rceil-1))(b^{p}-1)/(b-1)=(b^{p}-1)$.
\end{theorem}

\begin{proof}[Proof sketch]
Since $b$ is a valid-radix, we have $b>1$ which means $b-1>0$. We know
$\lceil b\rceil=b$, therefore $(\lceil b\rceil-1)/(b-1)=1$ since $b-1\neq0$.
The result follows immediately.
\end{proof}

<<Theorem: if $b\in\NN$, then $(\lceil b\rceil-1))(b^{p}-1)/(b-1)=(b^{p}-1)$>>=
theorem LmSigh:
  for b being valid_radix Nat
  holds (([/b\] -1)/(b - 1)) * ((b to_power p) - 1) = (b to_power p) - 1
proof
  let b be valid_radix Nat;
  b > 1 by Def1;
  then b + (-1) > 1 + (-1) by XREAL_1:8;
  then b - 1 > 1 - 1;
  then b - 1 > 0;
  then ([/b\] - 1)/(b - 1) = 1 by XCMPLX_1:60;
  hence (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1) = ((b to_power p) - 1);
end;
@ %def LmSigh

\begin{redefinition}
When $b\in\NN$ is a valid radix, the set of floating-point numbers may
be redefined by the criteria $x\in\RR$ is a floating-point number iff
there exists integers $M$ and $e$ such that $x=Mb^{e-p+1}$ and $|M|\leq b^{p}-1$
and $e_{\text{min}}\leq e\leq e_{\text{max}}$, or if $x=\pm\infty$.
\end{redefinition}

\begin{proof}[Proof sketch (compatibility)]
We need to prove this new redefinition is compatible with the old
definition, $\mathbb{F}_{\text{new}}\subset\mathbb{F}_{\text{old}}$ and
$\mathbb{F}_{\text{new}}\supset\mathbb{F}_{\text{old}}$. The heavy
lifting is provided by the previous theorem.
\end{proof}

<<Definition: [[FLOAT_NUMBER]] over integer radix>>=
definition
  let b be valid_radix Nat, p, eMin, eMax;
  redefine func FLOAT_NUMBER(b, p, eMin, eMax) equals :DefSigh:
  {x where x is Real : ex M, e being Integer
   st x = M * (b to_power (e - p + 1)) & |.M.| <= ((b to_power p) - 1)
   & eMin - 1 < e & e <= eMax } \/ {+infty, -infty};
  compatibility
  proof
    let A be Subset of ExtREAL;
    set NEW = {x where x is Real : ex M, e being Integer
    st x = M * (b to_power (e - p + 1)) & |.M.| <= (b to_power p) - 1
    & eMin - 1 < e & e <= eMax } \/ {+infty, -infty};

    A1: (([/b\] -1)/(b - 1)) * ((b to_power p) - 1) = (b to_power p) - 1
    by LmSigh;

    for z being object
    holds z in FLOAT_NUMBER(b, p, eMin, eMax) iff z in NEW
    proof
      let z be object;
      thus z in FLOAT_NUMBER(b, p, eMin, eMax) implies z in NEW
      proof
        assume z in FLOAT_NUMBER(b, p, eMin, eMax);
        then per cases by XBOOLE_0:def 3;
        suppose z in {x where x is Real :
          ex M being Element of b-radix_INT, e being Integer
          st x = M * (b to_power (e - p + 1))
          & |.M.| <= (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1)
          & eMin - 1 < e & e <= eMax };
          then B1: ex x being Real st z = x
          & ex M being Element of b-radix_INT, e being Integer
          st x = M * (b to_power (e - p + 1))
          & |.M.| <= ((b to_power p) - 1)
          & eMin - 1 < e & e <= eMax by A1;
          INT = b-radix_INT by Def1, ThBRadixINTCompatibility;
          then z in {x where x is Real : ex M, e being Integer
          st x = M * (b to_power (e - p + 1)) & |.M.| <= (b to_power p) - 1
          & eMin - 1 < e & e <= eMax } by B1;
          hence z in NEW by XBOOLE_0:def 3;
        end;
        suppose z in {+infty,-infty};
          hence thesis by XBOOLE_0:def 3;
        end;
      end;
      thus z in NEW implies z in FLOAT_NUMBER(b, p, eMin, eMax)
      proof
        assume z in NEW;
        then per cases by XBOOLE_0:def 3;
        suppose z in {x where x is Real : ex M, e being Integer
          st x = M * (b to_power (e - p + 1)) & |.M.| <= (b to_power p) - 1
          & eMin - 1 < e & e <= eMax };
          then ex x being Real st x = z & ex M, e being Integer
          st x = M * (b to_power (e - p + 1)) & |.M.| <= (b to_power p) - 1
          & eMin - 1 < e & e <= eMax;
          then consider M, e being Integer such that
          B1: z = M * (b to_power (e - p + 1)) & |.M.| <= (b to_power p) - 1
          & eMin - 1 < e & e <= eMax;
          INT = b-radix_INT by Def1, ThBRadixINTCompatibility;
          then B2: M is Element of b-radix_INT by INT_1:def 2;
          z in {x where x is Real :
          ex M being Element of b-radix_INT, e being Integer
          st x = M * (b to_power (e - p + 1))
          & |.M.| <= (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1)
          & eMin - 1 < e & e <= eMax } by A1,B1,B2;
          hence z in FLOAT_NUMBER(b, p, eMin, eMax) by XBOOLE_0:def 3;
        end;
        suppose z in {+infty, -infty};
          hence z in FLOAT_NUMBER(b, p, eMin, eMax) by XBOOLE_0:def 3;
        end;
      end;
    end;
    hence A = FLOAT_NUMBER(b, p, eMin, eMax) iff A = NEW by TARSKI:2;
  end;
end;
@ %def DefSigh

\begin{theorem}
For any real number $x\in\RR$ and integer $n\in\ZZ$, if $n<x\leq n+1$,
then $\lceil x\rceil = n+1$.
\end{theorem}

<<Theorem: If $n<x\leq n+1$, then $\lceil x\rceil=n+1$>>=
theorem LmCeil:
  for x being Real
  for n being Integer
  st n < x & x <= n + 1
  holds [/x\] = n + 1
proof
  let x be Real;
  let n be Integer;
  assume A1: n < x;
  assume A2: x <= n + 1;
  n + 1 < x + 1 by A1, XREAL_1:8;
  hence [/x\] = n+1 by A2, INT_1:def 7;
end;
@ %def LmCeil

\begin{theorem}
Let $\beta\in\RR$ be positive, let $p\in\NN$.
Then $0\leq\bigl((\lceil\beta\rceil-1)/(\beta-1)\bigr)(\beta^{p}-1)$.
\end{theorem}

\begin{proof}[Proof sketch]
There are two cases to consider here:
\begin{enumerate}
\item $0<\beta\leq 1$, in which case $\lceil\beta\rceil-1=0$ and then
  the result follows;
\item $1<\beta$, in which case $0\leq\bigl((\lceil\beta\rceil-1)/(\beta-1)\bigr)$,
  and $\beta^{p}>1$, so the right-hand side of our inequality is positive.
\end{enumerate}
Either way, the result follows.
\end{proof}

<<Theorem: $0\leq\bigl((\lceil\beta\rceil-1)/(\beta-1)\bigr)(\beta^{p}-1)$>>=
theorem LmZeroBound:
  0 <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
proof
  per cases;
  suppose A1: beta <= 1;
    then 0 < beta & beta <= 0 + 1;
    then [/beta\] + (-1) = 1 + (-1)  by LmCeil
                        .= 0;
    hence thesis;
  end;
  suppose A2: beta > 1;
    set a = (([/beta\] - 1)/(beta - 1));
    A3: 0 <= a
    proof
      beta - 1 > 1 - 1 by A2, XREAL_1:9;
      then B1: beta - 1 > 0;
      [/beta\] - 1 >= beta - 1 by XREAL_1:9, INT_1:def 7; 
      then ([/beta\] - 1)/(beta - 1) >= (beta - 1)/(beta - 1)
      by B1, XREAL_1:72;
      hence thesis by B1;
    end;
    set b = beta to_power p;
    b >= 1 by A2, POWER:35;
    then b - 1 >= 1 - 1 by XREAL_1:9;
    hence thesis by A3;
  end;
end;
@ %def LmZeroBound

\begin{theorem}
Zero is a floating-point number in any real base $\beta>0$.
\end{theorem}

\begin{proof}[Proof sketch]
We recall that zero is an element of $\ZZ_{\beta}$, so we take $M=0$ and
$e=0$, then the result follows.
\end{proof}

<<Theorem: zero is a floating-point number>>=
theorem ThZeroInFloatNumber:
  0 in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  reconsider M=0 as Element of beta-radix_INT by ThZeroInBetaINT;
  ex M being Element of beta-radix_INT, e being Integer
  st 0 = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax
  proof
    take M, e = 0;
    thus 0 = M * (beta to_power (e - p + 1));
    thus |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
    by LmZeroBound, COMPLEX1:44;
    thus eMin - 1 < e;
    thus e <= eMax;
  end;

  then 0 in {x where x is Real : ex M being Element of beta-radix_INT, e being Integer
   st x = M * (beta to_power (e - p + 1))
   & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
   & eMin - 1 < e & e <= eMax };
  hence thesis by XBOOLE_0:def 3;
end;
@ %def ThZeroInFloatNumber

\begin{registration}
We see that the set of floating-point numbers is nonempty.
\end{registration}

<<Register: [[FLOAT_NUMBER]] is non empty>>=
registration
  let beta, p, eMin, eMax;
  cluster FLOAT_NUMBER(beta, p, eMin, eMax) -> non empty;
  coherence;
end;
@ 

\begin{registration}
We observe there exists a real element of floating-point numbers, and
that all floating-point numbers are extended-reals.
\end{registration}

\begin{proof}[Proof sketch]
From the previous theorem, we see there exists at least one real
floating-point number --- namely, zero.

We also see, since floating-point numbers are defined as a subset of the
extended reals, that elements of the set of floating-point numbers
should be automatically recognized as extended-reals.
\end{proof}

<<Register: real for [[FLOAT_NUMBER]] and they're all extended reals>>=
registration
  let beta, p, eMin, eMax;
  cluster real for Element of FLOAT_NUMBER(beta, p, eMin, eMax);
  existence
  proof
    reconsider v=0 as Element of FLOAT_NUMBER(beta, p, eMin, eMax)
    by ThZeroInFloatNumber;
    take v;
    thus thesis;
  end;
  cluster -> ext-real for Element of FLOAT_NUMBER(beta, p, eMin, eMax);
  coherence;
end;
@ 

\begin{theorem}
Infinity is a floating-point number.
\end{theorem}

This is explicitly part of the standard, in \S3.2, that $+\infty$ and
$-\infty$ are floating-point numbers.

\begin{thm-remark}
We will adopt the naming convention that theorems which appear in the
Standard will be labeled ``$\mathtt{St}cs\mbox{\ss} xx$'' where $c$ is the
clause, $s$ the subclause, {\ss} the sub-subclause, and $x$ is a
unique number (possibly zero-padded).
\end{thm-remark}

<<Theorem: infinity is a float-poing number>>=
theorem St3200:
  -infty in FLOAT_NUMBER(beta, p, eMin, eMax)
  & +infty in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  -infty in {-infty,+infty} by TARSKI:def 2;
  hence -infty in FLOAT_NUMBER(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  +infty in {-infty,+infty} by TARSKI:def 2;
  hence +infty in FLOAT_NUMBER(beta, p, eMin, eMax) by XBOOLE_0:def 3;
end;
@ %def St3200

\begin{theorem}
Let $x$ be a real number.
Then $x\in\FF_{n}(\beta,p,e_{\text{min}},e_{\text{max}})$
if and only if there exists integers $e$ and $M$ such that
$x=M\cdot(b^{e-p+1})$ and $|M|\leq\beta^{p-1}$ and $e_{\text{min}}-1<e\leq e_{\text{max}}$.
\end{theorem}

\begin{proof}[Proof sketch]
This is a classic ``unroll the definitions'' proof, and just allows us
to side-step awkwardly using Fraenkel terms (the set construction object).
\end{proof}

<<Theorem: criteria for real numbers to be exact floating-point numbers>>=
theorem Th11:
  for x being Real
  holds x in FLOAT_NUMBER(beta, p, eMin, eMax) iff
  (ex M being Element of beta-radix_INT, e being Integer
  st x = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax)
proof
  set NUM = {x where x is Real : ex M being Element of beta-radix_INT, e being Integer
   st x = M * (beta to_power (e - p + 1))
   & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
   & eMin - 1 < e & e <= eMax };
  let x be Real;
  thus x in FLOAT_NUMBER(beta, p, eMin, eMax) implies
  (ex M being Element of beta-radix_INT, e being Integer
  st x = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax)
  proof
    assume A1: x in FLOAT_NUMBER(beta, p, eMin, eMax);
    then x in NUM or x in {+infty, -infty} by XBOOLE_0:def 3;
    then ex y being Real st x = y & ex M being Element of beta-radix_INT, e being Integer
    st y = M * (beta to_power (e - p + 1))
    & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
    & eMin - 1 < e & e <= eMax by TARSKI:def 2;
    hence thesis;
  end;
  thus (ex M being Element of beta-radix_INT, e being Integer
  st x = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax) implies x in FLOAT_NUMBER(beta, p, eMin, eMax)
  proof
    assume ex M being Element of beta-radix_INT, e being Integer st x = M * (beta to_power (e - p + 1)) & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1) & eMin - 1 < e & e <= eMax;
    then x in NUM;
    hence x in FLOAT_NUMBER(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  end;
end;
@ %def Th11

\begin{theorem}
Let $b\in\NN$ be a valid radix, let $x$ be a real number.
Then $x$ is a floating-point number in base $b$ if and only if there
exists integers $M$ and $e$ such that $x=Mb^{e-p+1}$ and $|M|\leq b^{p}-1$
and $e_{\text{min}}\leq e\leq e_{\text{max}}$.
\end{theorem}

<<Theorem: criterion for floating-point numbers over integer radix>>=
theorem Th12a:
  for b being valid_radix Nat
  for x being Real
  holds x in FLOAT_NUMBER(b, p, eMin, eMax) iff
  (ex M, e being Integer
   st x = M * (b to_power (e - p + 1)) & |.M.| <= ((b to_power p) - 1)
   & eMin - 1 < e & e <= eMax)
proof
  let b be valid_radix Nat;
  let x be Real;
  hereby 
    assume x in FLOAT_NUMBER(b, p, eMin, eMax);
    then consider M being Element of b-radix_INT, e being Integer such that
    A1: x = M * (b to_power (e - p + 1))
    & |.M.| <= (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1)
    & eMin - 1 < e & e <= eMax
    by Th11;
    M in b-radix_INT &
    b-radix_INT = INT by Def1, ThBRadixINTCompatibility;
    then M in INT;
    then reconsider M1 = M as Integer;
    take M1, e;
    thus x = M1 * (b to_power (e - p + 1)) by A1;
    (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1) = (b to_power p) - 1 by LmSigh;
    hence |.M1.| <= ((b to_power p) - 1) by A1;
    thus eMin - 1 < e by A1;
    thus e <= eMax by A1;
  end;
  given M, e being Integer such that 
  A1: x = M * (b to_power (e - p + 1)) & |.M.| <= ((b to_power p) - 1)
  & eMin - 1 < e & e <= eMax;
  M in INT by INT_1:def 2;
  then A2: M in b-radix_INT by Def1, ThBRadixINTCompatibility;
  |.M.| <= (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1) by A1, LmSigh;
  hence x in FLOAT_NUMBER(b, p, eMin, eMax) by A1, A2, Th11;
end;
@ 

\begin{lemma}
Let $y$ be an extended real number. If $y\in\RR$ and $y$ is a
floating-point number, then $-y$ is a floating-point number.
\end{lemma}

<<Lemma: if $y$ is floating-point number, then $-y$ is a floating-point number>>=
Lm7:
  for y being ExtReal st y in REAL
  holds y in FLOAT_NUMBER(beta, p, eMin, eMax)
  implies (- y) in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  let y be ExtReal;
  assume A1: y in REAL;
  assume y in FLOAT_NUMBER(beta, p, eMin, eMax);
  then consider M being Element of beta-radix_INT, e being Integer such that
  A2: y = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax
  by A1, Th11;
  A3: (- M) * (beta to_power (e - p + 1))
   = (-1) * ((M * (beta to_power (e - p + 1))) qua ExtReal)
  .= - y by A2, XXREAL_3:91;
  -M in beta-radix_INT & |.(- M).| = |.M.|
  by ThBetaRadixIntClosedUnderNegation, COMPLEX1:52;
  hence (- y) in FLOAT_NUMBER(beta, p, eMin, eMax) by A2,A3,Th11;
end;
@ %def Lm7

\begin{theorem}
Let $x$ be an extended real number. Then $x$ is a floating-point number
if and only if $-x$ is a floating-point number.
\end{theorem}

\begin{proof}[Proof sketch]
This is a proof by cases. Case 1: $x\in\RR$. Then we use the previous
lemma to obtain the result. Case 2: $x=-\infty$. Then $-x=+\infty$ which
is a floating-point number. Case 3: $x=+\infty$. Then $-x=-\infty$ which
is a floating-point number.
\end{proof}

<<Theorem: floating-point numbers closed under negation>>=
theorem ThFloatClosedUnderNegation:
  for x being ExtReal
  holds x in FLOAT_NUMBER(beta, p, eMin, eMax)
  iff (- x) in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  let x be ExtReal;
  A1: - -infty = +infty & - +infty = -infty by XXREAL_3:def 3;
  x in REAL \/ {+infty, -infty} by XXREAL_0:def 1,def 4;
  then x in REAL or x in {+infty, -infty} by XBOOLE_0:def 3;
  then per cases by TARSKI:def 2;
  suppose CASE1: x in REAL;
    thus x in FLOAT_NUMBER(beta, p, eMin, eMax)
    implies (- x) in FLOAT_NUMBER(beta, p, eMin, eMax) by CASE1,Lm7;
  
    A2: - x in REAL by CASE1, XREAL_0:def 1;
    assume (- x) in FLOAT_NUMBER(beta, p, eMin, eMax);
    then - (- x) = x & - (- x) in FLOAT_NUMBER(beta, p, eMin, eMax) by Lm7,A2;
    hence x in FLOAT_NUMBER(beta, p, eMin, eMax);
  end;
  suppose CASE2: x=+infty;
    hence thesis by A1, St3200;
  end;
  suppose CASE3: x=-infty;
    hence thesis by A1, St3200;
  end;
end;
@ %def ThFloatClosedUnderNegation

\begin{theorem}
Let $x\in\RR$ is a finite real number.
Then $x$ is a floating-point number if and only if $-x$ is a
floating-point number.
\end{theorem}

<<Theorem: finite real numbers are floating-point numbers iff their negation are floating-point numbers>>=
theorem ThFiniteFloatClosedUnderNegation:
  for x being Real
  holds x in FLOAT_NUMBER(beta, p, eMin, eMax)
  iff (- x) in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  let x be Real;
  reconsider y=x as ExtReal;
  thus x in FLOAT_NUMBER(beta, p, eMin, eMax)
  implies -x in FLOAT_NUMBER(beta, p, eMin, eMax)
  proof
    assume x in FLOAT_NUMBER(beta, p, eMin, eMax);
    then -y in FLOAT_NUMBER(beta, p, eMin, eMax) by ThFloatClosedUnderNegation;
    hence (- x) in FLOAT_NUMBER(beta, p, eMin, eMax)
    by XXREAL_3:def 3;
  end;
  assume (- x) in FLOAT_NUMBER(beta, p, eMin, eMax);
  then -y in FLOAT_NUMBER(beta, p, eMin, eMax) by XXREAL_3:def 3;
  hence x in FLOAT_NUMBER(beta, p, eMin, eMax) by ThFloatClosedUnderNegation;
end;
@ %def ThFiniteFloatClosedUnderNegation

\begin{theorem}
Let $x$ be a positive real number.
Then $x\in\FF_{n}(\beta,p,e_{\text{min}},e_{\text{max}})$
if and only if there exists integers $e$ and $M$ such that
$x=M\cdot(\beta^{e-p+1})$ and
$0<M\leq(\beta^{p}-1)(\lceil\beta\rceil-1)/(\beta-1)$ and
$e_{\text{min}}\leq e\leq e_{\text{max}}$.
\end{theorem}

<<Theorem: criteria for positive real numbers to be exact floating-point numbers>>=
theorem Th12:
  for x being positive Real
  holds x in FLOAT_NUMBER(beta, p, eMin, eMax) iff
  (ex M being Element of beta-radix_INT, e being Integer
  st x = M * (beta to_power (e - p + 1)) & 0 < M
  & M <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax)
proof
  let x be positive Real;
  thus x in FLOAT_NUMBER(beta, p, eMin, eMax) implies (ex M being Element of beta-radix_INT, e being Integer
  st x = M * (beta to_power (e - p + 1)) & 0 < M
  & M <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax)
  proof
    assume x in FLOAT_NUMBER(beta, p, eMin, eMax);
    then consider M being Element of beta-radix_INT, e being Integer such that
    A1: x = M * (beta to_power (e - p + 1))
    & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
    & eMin - 1 < e & e <= eMax by Th11;
    take M, e;
    thus x = M * (beta to_power (e - p + 1)) by A1;
    M > 0 by A1;
    then M = |.M.| by COMPLEX1:43;
    then M <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
    by A1;
    hence thesis by A1;
  end;
  given M being Element of beta-radix_INT, e being Integer such that 
  A2: x = M * (beta to_power (e - p + 1)) & 0 < M
  & M <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax;
  |.M.| = M by A2, COMPLEX1:43;
  hence thesis by A2, Th11;
end;
@ %def Th12

\begin{lemma}
Let $b\in\NN$ be a valid radix, let $p\in\NN$ be nonzero $p\neq0$.
Then $b^{p-1}\leq b^{p}-1$.
\end{lemma}

\begin{proof}[Proof sketch]
This follows by induction on $p$.
The base case $p=1$ requires proving $b^{0}\leq b-1$, which follows from
the definition of valid-radices $b>1$.

The inductive case, assuming $b^{p-1}\leq b^{p}-1$, we see that we can
multiply both sides by $b$ to obtain $b^{p}\leq b^{p+1}-b\leq b^{p+1}-1$.
\end{proof}

<<Lemma: $b^{p-1}\leq b^{p}-1$>>=
Lm17:
  for b being valid_radix Nat
  for p being non zero Nat
  holds b to_power (p - 1) <= (b to_power p) - 1
proof
  let b be valid_radix Nat;
  defpred P[Nat] means b to_power ($1 - 1) <= (b to_power $1) - 1;
  A1: P[1]
  proof
    b > 1 by Def1;
    then b - 1 >= 2 - 1 by NAT_1:23, XREAL_1:9;
    hence thesis by POWER:24;
  end;
  A2: for k being non zero Nat st P[k]
  holds P[k + 1]
  proof
    let k be non zero Nat;
    assume P[k];
    then B1: b * (b to_power (k - 1)) <= b * ((b to_power k) - 1)
    by XREAL_1:64;
    RHS: b * ((b to_power k) - 1) = ((b to_power 1) * (b to_power k)) - b
                                 .= (b to_power (1 + k)) - b by POWER:27;
    LHS: b * (b to_power (k - 1)) = (b to_power 1)*(b to_power (k - 1))
                                 .= b to_power (1 + (k - 1)) by POWER:27
                                 .= b to_power k;
    (b to_power (1 + k)) - b < (b to_power (1 + k)) - 1 by Def1, XREAL_1:10;
    hence thesis by B1, LHS, RHS, XXREAL_0:2;
  end;

  for k being non zero Nat holds P[k] from NAT_1:sch 10(A1, A2);
  hence b to_power (p - 1) <= (b to_power p) - 1;
end;
@ %def Lm17

\begin{theorem}
Let $b\in\NN$ be a valid radix.
Then $1\in\FF(b,p,e_{\text{min}},e_{\text{max}})$.
\end{theorem}

The critical premise is that $b$ is a valid radix, it could be real but
that greatly complicates the proof.

\begin{proof}[Proof sketch]
We see that $M=b^{p-1}\leq b^{p}-1$ and $e=0$ gives us the
floating-point value $1$.
\end{proof}

<<Theorem: if $b$ is a natural number, then $1\in\FF(b,p,e_{\text{min}},e_{\text{max}})$>>=
<<Lemma: $b^{p-1}\leq b^{p}-1$>>

theorem Th53:
  for b being valid_radix Nat
  holds 1 in FLOAT_NUMBER(b, p, eMin, eMax)
proof
  let b be valid_radix Nat;
  ex M, e being Integer
  st 1 = M * (b to_power (e - p + 1)) & |.M.| <= ((b to_power p) - 1)
  & eMin - 1 < e & e <= eMax
  proof
    p >= 0 + 1 by INT_1:7;
    then A1: p - 1 in NAT by INT_1:5;
    then reconsider p1=p - 1 as Nat;
    b to_power (p - 1) = b |^ p1 by POWER:41;
    then reconsider M = b to_power (p - 1) as Integer;
    take M;
    take e = 0;
    thus M * (b to_power (e - p + 1))
          = b to_power ((p - 1) + (e - p + 1)) by POWER:27
         .= 1 by POWER:24;
    |.M.| = M by COMPLEX1:43;
    hence |.M.| <= (b to_power p) - 1 by Lm17;
    thus eMin - 1 < e;
    thus e <= eMax;
  end;
  hence 1 in FLOAT_NUMBER(b, p, eMin, eMax) by Th12a;
end;
@ %def Th53

\begin{definition}
Let $\beta$ be a positive real number, let $p$ be a natural number,
let $e_{\text{min}}\in\ZZ\cup\{-\infty\}$ and
$e_{\text{max}}\in\NN\cup\{+\infty\}$ be negative and positive integers
or infinities.
We define the \define{Floating-Point Format} to be the set
$\FF(\beta,p,e_{\text{min}},e_{\text{max}})$ consisting of:
\begin{enumerate}
\item for any $x\in\RR$, we have $x\in\FF(\beta,p,e_{\text{min}},e_{\text{max}})$ if and only if there are integers $M$ and $e$ such that
  $x=M\beta^{e-p}$ and $|M|\leq \beta^{p}-1$ and
  $e_{\text{min}}\leq e\leq e_{\text{max}}$
\item $-\infty\in\FF(\beta,p,e_{\text{min}},e_{\text{max}})$
\item $+\infty\in\FF(\beta,p,e_{\text{min}},e_{\text{max}})$
\item $\NaN\in\FF(\beta,p,e_{\text{min}},e_{\text{max}})$
\item $-0\in\FF(\beta,p,e_{\text{min}},e_{\text{max}})$
\end{enumerate}
\end{definition}

<<Definition: floating-point format as [[FLOAT]]>>=
definition
  let beta, p, eMin, eMax;
  func FLOAT(beta, p, eMin, eMax) -> set equals
  FLOAT_NUMBER(beta, p, eMin, eMax) \/ {-0, NaN};
  coherence;
end;
@ %def FLOAT

\begin{voc}
We will tell Mizar to add [[FLOAT_NUMBER]] and [[FLOAT]] as new
constants for its lexer to recognize.
\end{voc}

<<DICT/float-1.voc>>=
OFLOAT_NUMBER
OFLOAT
@

\begin{definition}
Let $\beta$ be a positive real number,
let $p$ be a positive natural number,
$e_{\text{min}}$ be a negative extended integer,
$e_{\text{max}}$ be a positive extended integer.
Let $x$ be an object.
We say $x$ is a ``$(\beta,p,e_{\text{min}},e_{\text{max}})$-format floating-point''
if $x\in\FF(\beta,p,e_{\text{min}},e_{\text{max}})$.
\end{definition}

<<Definition: attribute $(\beta,p,e_{\text{min}},e_{\text{max}})$-format floating-point>>=
definition
  let beta, p, eMin, eMax;
  let IT be object;
  attr IT is (beta, p, eMin, eMax)-format_floating-point means :Def8a:
  IT in FLOAT(beta, p, eMin, eMax);
end;
@ %def -format_floating-point Def8a

\begin{voc}
We tell Mizar to add [[-format_floating-point]] as a token for an attribute.
\end{voc}

<<DICT/float-1.voc>>=
V-format_floating-point
@

\begin{registration}
There exists some [[(beta, p, eMin, eMax)-format_floating-point]]
number.
\end{registration}

<<Register: [[(beta, p, eMin, eMax)-format_floating-point]] for number>>=
registration
  let beta, p, eMin, eMax;
  cluster (beta, p, eMin, eMax)-format_floating-point for Number;
  existence
  proof
    -0 in {-0, NaN} by TARSKI:def 2;
    then -0 in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
    hence thesis by Def8a;
  end;
end;
@

\begin{definition*}
We define the type [[Float]] for a floating-point format Number.
\end{definition*}

<<Definition: [[Float]] for floating-point format Number>>=
:: Float of format beta, p, eMin, eMax
definition
  let beta, p, eMin, eMax;
  mode Float of beta, p, eMin, eMax is (beta, p, eMin, eMax)-format_floating-point Number;
end;
@ %def Float

\begin{voc}
We tell Mizar to add [[Float]] as a token for a mode.
\end{voc}

<<DICT/float-1.voc>>=
MFloat
@

\begin{registration}
We should tell Mizar that we can treat [[Float]] as a set.
\end{registration}

<<Register: sethood of [[Float]]>>=
registration
  let beta, p, eMin, eMax;
  sethood of Float of beta, p, eMin, eMax
  proof
    take FLOAT(beta, p, eMin, eMax);
    thus thesis by Def8a;
  end;
end;
@ 

\begin{theorem}
Zero is a Float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$.
\end{theorem}

<<Theorem: Zero is a Float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$>>=
theorem ThZeroIsFloat:
  0 is Float of beta, p, eMin, eMax
proof
  0 in FLOAT_NUMBER(beta, p, eMin, eMax)
  by ThZeroInFloatNumber;
  then 0 in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  hence thesis by Def8a;
end;
@ %def ThZeroIsFloat

\begin{registration}
We observe there exists an extended real element of [[FLOAT]].
\end{registration}

<<Register: [[ext-real]] and [[real]] for [[Float]]>>=
registration
  let beta, p, eMin, eMax;
  cluster ext-real for Float of beta, p, eMin, eMax;
  existence
  proof
    reconsider v=0 as Float of beta,p,eMin,eMax by ThZeroIsFloat;
    take v;
    thus thesis;
  end;
  cluster real for Float of beta, p, eMin, eMax;
  existence
  proof
    reconsider v=0 as Float of beta,p,eMin,eMax by ThZeroIsFloat;
    take v;
    thus thesis;
  end;
end;
@

\begin{registration}
We see that there is a zero Float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$.
\end{registration}

<<Register: [[zero]] and [[non zero]] for [[Float]]>>=
registration
  let beta, p, eMin, eMax;
  cluster zero for Float of beta, p, eMin, eMax;
  existence
  proof
    reconsider v=0 as Float of beta,p,eMin,eMax by ThZeroIsFloat;
    take v;
    thus thesis;
  end;
  cluster non zero for Float of beta, p, eMin, eMax;
  existence
  proof
    NaN in {-0,NaN} by TARSKI:def 2;
    then NaN in FLOAT(beta,p,eMin,eMax) by XBOOLE_0:def 3;
    then reconsider v=NaN as Float of beta,p,eMin,eMax by Def8a;
    take v;
    thus thesis;
  end;
end;
@

\begin{theorem}
We see that $-\infty$ is a float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$;
and $+\infty$ is a float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$.
\end{theorem}

<<Theorem: $\pm\infty$ is a float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$>>=
theorem St3201:
  -infty is Float of beta,p,eMin,eMax
  & +infty is Float of beta,p,eMin,eMax
proof
  -infty in FLOAT_NUMBER(beta, p, eMin, eMax) by St3200;
  then -infty in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  hence -infty is Float of beta, p, eMin, eMax by Def8a;
  +infty in FLOAT_NUMBER(beta, p, eMin, eMax) by St3200;
  then +infty in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  hence +infty is Float of beta, p, eMin, eMax by Def8a;
end;
@ %def St3201

\begin{definition}
We can define the attributes \define{positive} and \define{negative} for
Floats of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$ by the
criteria that it is equal to a positive (resp., negative) extended real
number. 
\end{definition}

<<Definition: [[positive]] and [[negative]] for [[Float]]>>=
definition
  let beta, p, eMin, eMax;
  let IT be Float of beta, p, eMin, eMax;
  attr IT is positive means :Def9a:
  ex x being positive ExtReal st IT = x;
  attr IT is negative means :Def9b:
  ex x being negative ExtReal st IT = x;
end;
@ %def Def9a Def9b positive negative

\begin{registration}
We see that positive and negative Floats of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$
are automatically extended real numbers.
\end{registration}

<<Register: positive and negative Floats are extended-reals>>=
registration
  let beta, p, eMin, eMax;
  cluster positive -> non zero ext-real for Float of beta,p,eMin,eMax;
  coherence;
  cluster negative -> non zero ext-real for Float of beta,p,eMin,eMax;
  coherence;
end;
@ 

\begin{registration}
We see there exists positive, negative, non-positive, and non-negative
Floats of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$.
\end{registration}

<<Register: positive, negative, non-positive, non-negative Floats>>=
registration
  let beta, p, eMin, eMax;
  cluster positive ext-real for Float of beta,p,eMin,eMax;
  existence
  proof
    reconsider v=+infty as Float of beta,p,eMin,eMax by St3201;
    take v;
    thus thesis;
  end;
  cluster negative ext-real for Float of beta,p,eMin,eMax;
  existence
  proof
    reconsider v=-infty as Float of beta,p,eMin,eMax by St3201;
    take v;
    thus thesis;
  end;
  cluster non positive ext-real for Float of beta,p,eMin,eMax;
  existence
  proof
    reconsider v=-infty as Float of beta,p,eMin,eMax by St3201;
    take v;
    thus thesis;
  end;
  cluster non negative ext-real for Float of beta,p,eMin,eMax;
  existence
  proof
    reconsider v=+infty as Float of beta,p,eMin,eMax by St3201;
    take v;
    thus thesis;
  end;
end;
@

\begin{theorem}
Let $x$ be a negative float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$.
Then $x < 0$ as an extended real number.
\end{theorem}

\begin{proof}[Proof sketch]
This follows from the registered fact that negative Floats are extended
real numbers, and the definition of ``negative''.
\end{proof}

<<Theorem: negative Floats are less than zero>>=
theorem ThNegativeFloat:
  for v being negative Float of beta,p,eMin,eMax
  holds v < 0
proof
  let v be negative Float of beta,p,eMin,eMax;
  ex x being negative ExtReal st x = v by Def9b;
  hence v < 0;
end;
@ %def ThNegativeFloat

\begin{theorem}
Let $x$ be a positive float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$.
Then $x > 0$ as an extended real number.
\end{theorem}

<<Theorem: positive Floats are greater than zero>>=
theorem ThPositiveFloat:
  for v being positive Float of beta,p,eMin,eMax
  holds v > 0
proof
  let v be positive Float of beta,p,eMin,eMax;
  ex x being positive ExtReal st x = v by Def9a;
  hence v > 0;
end;
@ %def ThPositiveFloat

\begin{theorem}
Let $x$ be any object.
Then $x$ is an extended-real Float of format $\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$
if and only if $x$ is an element of the set [[FLOAT_NUMBER]]($\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$).
\end{theorem}

<<Theorem: extended-real [[Float]] are elements of [[FLOAT_NUMBER]]>>=
theorem ThRealFloatsAreInFLOATNUMBER:
  for x being object
  holds x is ext-real Float of beta, p, eMin, eMax
  iff x in FLOAT_NUMBER(beta, p, eMin, eMax)
proof
  let x be object;
  hereby
    assume A1: x is ext-real Float of beta, p, eMin, eMax;
    then x in FLOAT(beta, p, eMin, eMax) by Def8a;
    then x in FLOAT_NUMBER(beta, p, eMin, eMax)
    or x in {-0, NaN} by XBOOLE_0:def 3;
    then x in FLOAT_NUMBER(beta, p, eMin, eMax)
    or x=-0 or x=NaN by TARSKI:def 2;
    hence x in FLOAT_NUMBER(beta, p, eMin, eMax) by A1;
  end;
  assume A2: x in FLOAT_NUMBER(beta, p, eMin, eMax);
  then x in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  then x is Float of beta, p, eMin, eMax by Def8a;
  hence x is ext-real Float of beta, p, eMin, eMax by A2;
end;
@ %def ThRealFloatsAreInFLOATNUMBER

\begin{theorem}
Let $b$ be a valid radix real number (\emph{not} ``merely'' a positive real).
When $e_{\text{min}}\in\ZZ$ is finite, the smallest positive
Float of format $b$, $p$, $e_{\text{min}}$, $e_{\text{max}}$
is $b^{e_{\text{min}}-p+1}$.
\end{theorem}

\begin{proof}[Proof sketch]
Let $x$ be any positive Float. We will prove $b^{e_{\text{min}}-p+1}\leq x$
by cases.

\textsc{Case 1:} $x\in\RR$. Then $x$ is in [[FLOAT_NUMBER]]
which allows us to write $x=M\cdot b^{e-p+1}$ for some integers $M$, $e$
where $0<M\leq b^{p-1}$. After some arithmetic, we see the inequality is
satisfied since $1\leq M$ and $e_{\text{min}}\leq e$.

\textsc{Case 2:} $x=+\infty$. Then the result follows since $b^{e_{\text{min}}-p+1}\in\RR$.

\textsc{Case 3:} $x=-\infty$. This contradicts the premise that $x$ is
positive, which means we'd never encounter this situation.
\end{proof}

When we allow $e_{\text{min}}=-\infty$, this theorem fails to hold
(obviously).

<<Theorem: smallest [positive] Float of format $b$, $p$, $e_{\text{min}}$, $e_{\text{max}}$>>=
theorem St3300:
  for eMin being negative Integer
  for x being positive Float of b, p, eMin, eMax
  holds b to_power (eMin - p + 1) <= x
proof
  let eMin be negative Integer;
  let x be positive Float of b, p, eMin, eMax;
  x in REAL \/ {+infty,-infty} by XXREAL_0:def 1,def 4;
  then x in REAL or x in {+infty,-infty} by XBOOLE_0:def 3;
  then per cases by TARSKI:def 2;
  suppose A1: x in REAL;
    then reconsider X=x as positive Real by ThPositiveFloat;
    x in FLOAT_NUMBER(b, p, eMin, eMax) by ThRealFloatsAreInFLOATNUMBER;
    then consider M being Element of b-radix_INT, e being Integer such that
    A3: X = M * (b to_power (e - p + 1)) & 0 < M
    & M <= (([/b\] - 1)/(b - 1)) * ((b to_power p) - 1)
    & eMin - 1 < e & e <= eMax by Th12;
    eMin - 1 + 1 <= e by A3, INT_1:7;
    then eMin + (1 - p) <= e + (1 - p) by XREAL_1:6;
    then A4: (b to_power (eMin - p + 1)) <= (b to_power (e - p + 1))
    by Def1, Th1;
    1 <= M by A3, ThSmallestPositiveBetaRadixInt;
    then 1 * (b to_power (e - p + 1)) <= M * (b to_power (e - p + 1))
    by XREAL_1:64;
    hence (b to_power (eMin - p + 1)) <= x by A3, A4, XXREAL_0:2;
  end;
  suppose x=+infty;
    hence b to_power (eMin - p + 1) <= x by XREAL_0:def 1, XXREAL_0:9;
  end;
  suppose x=-infty;
    hence thesis by ThPositiveFloat;
  end;
end;
@ %def St3300

\begin{theorem}\label{thm:ThPositiveFloatIsRealOrInfinity}
Positive floats are either real or $+\infty$.
\end{theorem}

<<Theorem: positive Floats are either real or $+\infty$>>=
theorem ThPositiveFloatIsRealOrInfinity:
  for v being positive Float of beta, p, eMin, eMax
  holds v is real or v = +infty
proof
  let v be positive Float of beta, p, eMin, eMax;
  assume not v is real;
  then A1: not v in REAL;
  ex x being positive ExtReal st x = v by Def9a;
  hence v = +infty by A1, XXREAL_0:14;
end;
@ %def ThPositiveFloatIsRealOrInfinity

\begin{theorem}
Negative floats are either real or $+\infty$.
\end{theorem}

<<Theorem: negative Floats are either real or $-\infty$>>=
theorem ThNegativeFloatIsRealOrInfinity:
  for v being negative Float of beta, p, eMin, eMax
  holds v is real or v = -infty
proof
  let v be negative Float of beta, p, eMin, eMax;
  assume not v is real;
  then A1: not v in REAL;
  ex x being negative ExtReal st x = v by Def9b;
  hence v = -infty by A1, XXREAL_0:14;
end;
@ %def ThNegativeFloatIsRealOrInfinity

\begin{theorem}
Let $e_{\text{min}}$ be a negative integer, let $x$ be a Float of format
$\beta$, $p$, $e_{\text{min}}$, $e_{\text{max}}$. Then there exists an
$n\in\ZZ_{\beta}$ such that $n\beta^{e_{\text{min}}-p+1}=x$.
\end{theorem}

<<Theorem: $x\in\FF_{\beta}$, $\exists n\in\ZZ_{\beta}.x=n\beta^{e_{\text{min}}-p+1}$>>=
theorem St3301:
  for eMin being negative Integer
  for x being real Float of beta, p, eMin, eMax
  ex n being Element of beta-radix_INT
  st n*(beta to_power (eMin - p + 1)) = x
proof
  let eMin be negative Integer;
  let x be real Float of beta, p, eMin, eMax;
  x in FLOAT_NUMBER(beta, p, eMin, eMax) by ThRealFloatsAreInFLOATNUMBER;
  then consider M being Element of beta-radix_INT, e being Integer such that
  A1: x = M * (beta to_power (e - p + 1))
  & |.M.| <= (([/beta\] - 1)/(beta - 1)) * ((beta to_power p) - 1)
  & eMin - 1 < e & e <= eMax
  by Th11;
  (eMin - 1) + 1 <= e by A1, INT_1:7;
  then eMin - eMin <= e - eMin by XREAL_1:9;
  then e - eMin in NAT by INT_1:3;
  then reconsider n = M*(beta to_power (e - eMin)) as Element of beta-radix_INT
  by ThLeftShiftBetaRadixINT;
  take n;
  thus n*(beta to_power (eMin - p + 1))
   = M * ((beta to_power (e - eMin)) * (beta to_power (eMin - p + 1)))
  .= M * (beta to_power ((e - eMin) + (eMin - p + 1))) by POWER:27
  .= x by A1;
end;
@ %def St3301

\begin{theorem}
Let $b$ be a valid-radix integer.
When $e_{\text{min}}\in\ZZ$ is finite, every Float of format $b$, $p$,
$e_{\text{min}}$, $e_{\text{max}}$ is an integer multiple of
$b^{e_{\text{min}}-p+1}$.
\end{theorem}

The standard says this in passing, but doesn't prove it. This is an
immediate corollary to the previous theorem.

<<Theorem: floating-point numbers are integer multiples of $\beta^{e_{\text{min}}-p+1}$>>=
<<Theorem: $x\in\FF_{\beta}$, $\exists n\in\ZZ_{\beta}.x=n\beta^{e_{\text{min}}-p+1}$>>

theorem St3302:
  b in INT implies
  for eMin being negative Integer
  for x being real Float of b, p, eMin, eMax
  ex n being Integer
  st n*(b to_power (eMin - p + 1)) = x
proof
  assume b in INT;
  then A1: b in NAT by INT_1:3;
  let eMin be negative Integer;
  let x be real Float of b, p, eMin, eMax;
  b-radix_INT = INT by Def1, A1, ThBRadixINTCompatibility;
  then ex n being Element of INT
  st n*(b to_power (eMin - p + 1)) = x by St3301;
  hence thesis;
end;
@ %def St3302

\begin{corollary}
Let $b$ be a valid radix natural number.
The smallest positive floating-point number is $b^{e_{\text{min}}-p+1}$.
\end{corollary}

\begin{proof}[Proof sketch]
Let $x$ be a positive Float. Then by Theorem~\ref{thm:ThPositiveFloatIsRealOrInfinity} it must either be real or infinite.
So we have a proof by cases.

\textsc{Case 1:} when $x$ is real, we see we can write it as an integer
multiple of $n\cdot b^{e_{\text{min}}-p+1}=x$ by the previous
Theorem. Since $x$ is positive, this requires
$n>0$. Then $n\geq1$. The result follows immediately.

\textsc{Case 2:} when $x=+\infty$, the result is obvious.
\end{proof}

<<Corollary: the smallest positive floating-point number is $b^{e_{\text{min}}-p+1}$>>=
theorem ThSmallestPositiveFloat:
  for eMin being negative Integer
  for b being valid_radix Nat
  for x being positive Float of b, p, eMin, eMax
  holds (b to_power (eMin - p + 1)) <= x
proof
  let eMin be negative Integer;
  let b be valid_radix Nat;
  let x be positive Float of b, p, eMin, eMax;
  A1: x in FLOAT_NUMBER(b, p, eMin, eMax) by ThRealFloatsAreInFLOATNUMBER;
  per cases by ThPositiveFloatIsRealOrInfinity;
  suppose A2: x is real;
    b in NAT by ORDINAL1:def 12;
    then b in INT by NUMBERS:17;
    then consider n being Integer such that
    A3: n*(b to_power (eMin - p + 1)) = x
    by A2, St3302;
    x is positive real by A2;
    then n is positive by A3;
    then 0 + 1 <= n by INT_1:7;
    then 1 * (b to_power (eMin - p + 1)) <= n * (b to_power (eMin - p + 1))
    by XREAL_1:64;
    hence (b to_power (eMin - p + 1)) <= x by A3;
  end;
  suppose x = +infty;
    hence thesis by XXREAL_0:3;
  end;
end;
@ %def ThSmallestPositiveFloat

\begin{corollary}
Let $e_{\text{min}}$ be a negative integer, $b$ be a valid radix natural number.
The smallest negative floating-point number is $-b^{e_{\text{min}}-p+1}$.
\end{corollary}

<<Corollary: Smallest negative floating-point number>>=
theorem ThSmallestNegativeFloat:
  for eMin being negative Integer
  for b being valid_radix Nat
  for x being negative Float of b, p, eMin, eMax
  holds x <= -(b to_power (eMin - p + 1))
proof
  let eMin be negative Integer;
  let b be valid_radix Nat;
  let x be negative Float of b, p, eMin, eMax;
  per cases by ThNegativeFloatIsRealOrInfinity;
  suppose A1: x is real;
    b in NAT by ORDINAL1:def 12;
    then consider n being Integer such that
    A2: n*(b to_power (eMin - p + 1)) = x
    by A1, St3302, NUMBERS:17;
    x is negative real by A1;
    then n is negative by A2;
    then n <= -1 by INT_1:8;
    then n * (b to_power (eMin - p + 1)) <= (-1) * (b to_power (eMin - p + 1))
    by XREAL_1:64;
    hence x <= - (b to_power (eMin - p + 1)) by A2;
  end;
  suppose x = -infty;
    hence thesis by XXREAL_0:5;
  end;
end;
@ %def ThSmallestNegativeFloat

\subsection{Sets of floating-point data}

\begin{definition}
Let $x$ be a floating-point datum belonging to the format $\FF(\beta,p,e_{\text{min}},e_{\text{max}})$.
We say $x$ is \define{Normal} if
\begin{enumerate}
\item when $e_{\text{min}}=-\infty$, $x\neq0$ is a finite floating-point number;
\item otherwise, $x\in\RR$ and its magnitude is not less than
  $\beta^{e_{\text{min}}}\leq|x|$.
\end{enumerate}
\end{definition}

\begin{def-remark}
We want to preserve the classes of floating-point numbers (i.e., we want
a floating-point datum to be: zero, subnormal, normal, infinite, or NaN,
but exactly one of these). This generalizes the definition for the
$e_{\text{min}}=-\infty$ case, and preventing infinity from being a
normal floating-point number is satisfied by the $x\in\RR$ demand.
\end{def-remark}

This definition gives us a peculiar situation: zero is not a normal
floating-point number. Neither is it a subnormal number (which are
defined to be nonzero). Perhaps there is a good rationale for this, but
it seems unintuitive that $0$ is not normal.

<<Definition: normal floating-point number>>=
definition
  let beta, p, eMin, eMax;
  let IT be Float of beta, p, eMin, eMax;
  attr IT is normal means :Def8:
  IT is real & IT <> 0 if eMin = -infty
  otherwise IT is real & ex x being Real, iMin being negative Integer
  st iMin = eMin & x = IT & beta to_power iMin <= |.x.|;
  consistency;
end;
@ %def normal Def8

\begin{registration}
If a floating-point number is normal, then it is also a real number.
\end{registration}

This literally follows from the definition of ``normal'', but Mizar
needs our help to break it up into the cases when $e_{\text{min}}=-\infty$
and when $e_{\text{min}}\neq\infty$.

<<Register: normal implies real for floating-point numbers>>=
registration
  let beta, p, eMin, eMax;
  cluster normal -> real for Float of beta, p, eMin, eMax;
  coherence
  proof
    let v be Float of beta, p, eMin, eMax;
    assume A1: v is normal;
    per cases;
    suppose eMin = -infty;
      hence thesis by A1, Def8;
    end;
    suppose eMin <> -infty;
      hence thesis by A1, Def8;
    end;
  end;
end;
@ 

\begin{theorem}
If $e_{\text{min}}\in\ZZ$,
then $v\in\FF(\beta,p,e_{\text{min}},e_{\text{max}})$ is normal if and only if
there exists a $x\in\RR$ such that $x=v$ and $\beta^{e_{\text{min}}}\leq x$.
\end{theorem}

\begin{proof}[Proof sketch]
This simply ``unrolls'' the definition of ``normal'' floating-point
numbers to match the case specified by the hypotheses that
$e_{\text{min}}\in\ZZ$.
\end{proof}

<<Theorem: criterion for normal floating-point numbers with $e_{\text{min}}\in\ZZ$ and $e_{\text{max}}\in\ZZ$>>=
theorem ThNormalFloatCriteriaFiniteExp:
  for eMin being negative Integer
  for v being Float of beta, p, eMin, eMax
  holds v is normal iff ex x being Real st x = v
  & beta to_power eMin <= |.x.|
proof
  let eMin be negative Integer;
  let v be Float of beta, p, eMin, eMax;
  thus v is normal implies ex x being Real st x = v
  & beta to_power eMin <= |.x.|
  proof
    assume v is normal;
    then ex x being Real, iMin being negative Integer st iMin = eMin
    & x = v
    & beta to_power iMin <= |.x.| by Def8;
    hence thesis;
  end;
  given x being Real such that 
  A1: x = v & beta to_power eMin <= |.x.|;
  thus v is normal by A1, Def8;
end;
@ %def ThNormalFloatCriteriaFiniteExp

The question of \emph{when do normal floating-point numbers exist} is
rather tricky to answer in the abstract, because we can always pick an
arbitrarily small base to complicate things. When we work with
$e_{\text{min}}$ and $e_{\text{max}}$ being integers, the condition for
the existence of at least one normal floating-point number boils down to
\begin{equation}
b^{e_{\text{min}}}\leq b^{1+e_{\text{max}}}(1 - b^{-p}).
\end{equation}

\begin{proposition}
When $e_{\text{min}}+e_{\text{max}}=1$, and $b=1+\varepsilon$ for $0<\varepsilon\ll4/(1+e_{\text{max}})$,
there are no normal floating-point numbers.
\end{proposition}

\begin{proof}
When $b=1+\varepsilon$ for a positive but tiny $\varepsilon$, we
see the Binomial series truncated to first order gives us
\begin{equation}
1 + e_{\text{min}}\varepsilon\leq (1 + [1 + e_{\text{max}}]\varepsilon)(1 - (1 - p\varepsilon)) 
= (1 + [1 + e_{\text{max}}]\varepsilon)p\varepsilon.
\end{equation}
Rearranging terms, we see this requires
\begin{equation}
1 + e_{\text{min}}\varepsilon\leq p\varepsilon + [1 + e_{\text{max}}]p\varepsilon^{2},
\end{equation}
or equivalently
\begin{equation}
1\leq(p- e_{\text{min}})\varepsilon + [1 + e_{\text{max}}]p\varepsilon^{2}.
\end{equation}
If we use the condition that the IEEE Standard uses relating exponents,
$e_{\text{max}}+e_{\text{min}}=1$, and if we stipulate that $p>2$ and
$e_{\text{max}}>1$, then we obtain the inequality
\begin{equation}
p + (1 + e_{\text{max}}) + 2p(1 + e_{\text{max}})\varepsilon\geq2 +
\sqrt{p^{2} + (e_{\text{max}}-1)^{2}+p(6e_{\text{max}}+2)}.
\end{equation}
This gives us the inequality
\begin{equation}
\varepsilon\geq\frac{2 - p - (1 + e_{\text{max}}) + \sqrt{p^{2} + (e_{\text{max}}-1)^{2}+p(6e_{\text{max}}+2)}}{2p(1 + e_{\text{max}})}>0.
\end{equation}
When $p=7$ and $e_{\text{max}}=96$ (i.e., we use the decimale-32 format
from the IEEE standard), we see that we need
$\varepsilon\geq(4\sqrt{205}-51)/679\approx0.00923606$ for a normal
floating-point number to exist. So for smaller bases (say, $b=1+10^{-5}$),
there are no normal floating-point numbers with precision $p=7$ and
exponent bounds $e_{\text{max}}=96$, $e_{\text{min}}=-95$. Worse, there
are no values of $p$ and $e_{\text{max}}$ for which the right-hand side
vanishes --- i.e., for which $\varepsilon\geq0$.

When this inequality \emph{fails} to hold is of interest to us,
specifically when
\begin{equation}
\varepsilon<\frac{2 - p - (1 + e_{\text{max}}) + \sqrt{p^{2} + (e_{\text{max}}-1)^{2}+p(6e_{\text{max}}+2)}}{2p(1 + e_{\text{max}})}.
\end{equation}
We can rearrange this expression to find
\begin{subequations}
\begin{equation}
1 + e_{\text{max}} < \frac{1}{\varepsilon+2\varepsilon^{2}},
\end{equation}
and
\begin{equation}
2 < p < \frac{1 + \varepsilon - e_{\text{max}}\varepsilon}{\varepsilon + (1+e_{\text{max}})\varepsilon^{2}}.
\end{equation}
Observe since $0<\varepsilon\ll 1$, the upper bound on $p$ is meaningless.
\end{subequations}
The first inequality can be rearranged to find
\begin{equation}
4\varepsilon < \sqrt{\frac{9+e_{\text{max}}}{1+e_{\text{max}}}}-1 < \frac{4}{1+e_{\text{max}}}.
\end{equation}
Thus we obtain a criterion for the non-existence of normal floating-point
numbers for an arbitrary radix $b=1+\varepsilon$ (for $0<\varepsilon\ll1$) when $e_{\text{min}}+e_{\text{max}}=1$.
\end{proof}

We need to prove a number of lemmas concerning the bounds on powers of
the radix.

\begin{lemma}
Let $b$ be a valid radix number. Then $b^{1-p}\leq1$ and $1\leq b^{p-1}$.
\end{lemma}

\begin{proof}[Proof sketch]
Since $p\geq1$, then $0\geq 1-p$ and so $b^{0}\geq b^{1-p}$.
Similar reasoning gives $p-1\geq0$ thus $b^{p-1}\geq b^{0}$.
\end{proof}

<<Lemma: $b^{1-p}\leq1$ and $1\leq b^{p-1}$>>=
Lm19:
  b to_power (1 - p) <= 1
  & 1 <= b to_power (p - 1)
proof
  A1: p >= 0 + 1 by INT_1:7;
  then 1 - p <= 1 - 1 by XREAL_1:13;
  then b to_power (1 - p) <= b to_power 0 by Def1,Th1;
  hence b to_power (1 - p) <= 1 by POWER:24;
  1 - 1 <= p - 1 by A1, XREAL_1:9;
  then b to_power 0 <= b to_power (p - 1) by Def1,Th1;
  hence 1 <= b to_power (p - 1) by POWER:24;
end;
@ %def Lm19

\begin{lemma}
Let $e_{\text{max}}$ be a positive integer. Then $b\leq b^{e_{\text{max}}}$.
\end{lemma}

<<Lemma: $b\leq b^{e_{\text{max}}}$>>=
Lm20:
  for eMax being positive Integer
  holds b <= b to_power eMax
proof
  let eMax be positive Integer;
  0 + 1 <= eMax by INT_1:7;
  then b to_power 1 <= b to_power eMax by Def1,Th1;
  hence b <= b to_power eMax;
end;
@ %def Lm20

\begin{lemma}
Let $e_{\text{max}}$ be a positive integer. Then $b(b-1)\leq b^{e_{\text{max}}}(b-b^{1-p})$.
\end{lemma}

<<Lemma: $b(b-1)\leq b^{e_{\text{max}}}(b-b^{1-p})$>>=
Lm21:
  for eMax being positive Integer
  holds b * (b - 1) <= (b to_power eMax)*(b - (b to_power (1 - p)))
proof
  let eMax be positive Integer;
  A1: 0 <= b - 1 & 0 <= b
  proof
    b > 1 by Def1;
    hence 0 <= b - 1 by XREAL_1:48;
    thus 0 <= b;
  end;
  1 >= b to_power (1 - p) by Lm19;
  then A2: b - 1 <= b - (b to_power (1 - p)) by XREAL_1:13;
  b <= b to_power eMax by Lm20;
  hence b * (b - 1) <= (b to_power eMax)*(b - (b to_power (1 - p)))
  by A1, A2, XREAL_1:66;
end;
@ %def Lm21

\begin{theorem}
If $1\in\FF(\beta,p,-\infty,e_{\text{max}})$, then 1 is normal.
\end{theorem}

<<Theorem: If $1\in\FF(\beta,p,-\infty,e_{\text{max}})$, then 1 is normal>>=
theorem ThNormalFloatInNegInfty:
  for x being Float of beta, p, eMin, eMax
  st x=1 & eMin=-infty
  holds x is normal by Def8;
@ %def ThNormalFloatInNegInfty

\begin{theorem}
If $1\in\FF(\beta,p,e_{\text{min}},+\infty)$, then 1 is normal.
\end{theorem}

<<Theorem: If $1\in\FF(\beta,p,e_{\text{min}},+\infty)$, then 1 is normal>>=
theorem ThNormalFloatInPosInfty:
  for x being Float of b, p, eMin, eMax
  st x=1 & eMax=+infty
  holds x is normal
proof
  let x be Float of b, p, eMin, eMax;
  assume A1: x=1;
  assume A2: eMax=+infty;
  per cases;
  suppose eMin=-infty;
    hence thesis by ThNormalFloatInNegInfty,A1;
  end;
  suppose A3: eMin <> -infty;
    then reconsider iMin = eMin as negative Integer by ThNegExtInt;
    reconsider x1=x as Real by A1;
    b > 1 by Def1;
    then b to_power iMin < |.x1.| by A1,COMPLEX1:48,POWER:36;
    hence x is normal by Def8;
  end;
end;
@ %def ThNormalFloatInPosInfty

\begin{theorem}
If $b\in\NN$, then there exists a normal element of $\FF(b,p,e_{\text{min}},e_{\text{max}})$.
\end{theorem}

<<Theorem: If $b\in\NN$, then there exists a normal floating-point number>>=
theorem ThExistenceNormalFloat:
  for b being valid_radix Nat
  ex x being Float of b, p, eMin, eMax
  st x is normal
proof
  let b be valid_radix Nat;
  1 in FLOAT_NUMBER(b, p, eMin, eMax) by Th53; then
  1 in FLOAT(b, p, eMin, eMax) by XBOOLE_0:def 3; then
  A1: 1 is Float of b, p, eMin, eMax by Def8a;
  per cases;
  suppose eMin=-infty;
    hence thesis by A1, ThNormalFloatInNegInfty;
  end;
  suppose eMax=+infty;
    hence thesis by A1, ThNormalFloatInPosInfty;
  end;
  suppose A2: eMin <> -infty & eMax <> +infty;
    then reconsider iMin=eMin as negative Integer by ThNegExtInt;
    reconsider iMax=eMax as positive Integer by A2, ThPosExtInt;
    reconsider x0 = 1 as Float of b, p, eMin, eMax by A1;
    take x0;
    ex x being Real st x = x0
    & b to_power iMin <= |.x.|
    & |.x.| <= (b to_power iMax)*(b - (b to_power (1 - p)))
    proof
      take x = 1;
      thus x = x0;
      b > 1 & iMin < 0 by Def1;
      hence b to_power iMin <= |.x.| by COMPLEX1:48, POWER:36;
      1 < b by Def1;
      then A3: 1 + 1 <= b by INT_1:7;
      then 2 + (- 1) <= b + (- 1) by XREAL_1:6;
      then A4: 2 * 1 <= b * (b - 1) by A3, XREAL_1:66;
      b * (b - 1) <= (b to_power iMax)*(b - (b to_power (1 - p))) by Lm21;
      then 2 <= (b to_power iMax)*(b - (b to_power (1 - p))) by A4, XXREAL_0:2;
      hence |.x.| <= (b to_power iMax)*(b - (b to_power (1 - p)))
      by COMPLEX1:48, XXREAL_0:2;
    end;
    hence x0 is normal by Def8;
  end;
end;
@ %def ThExistenceNormalFloat

\begin{registration}
Observe there exists a normal floating-point number.
\end{registration}

<<Register: normal floating-point datum>>=
registration
  let b be valid_radix Nat, p, eMin, eMax;
  cluster normal for Float of b, p, eMin, eMax;
  existence by ThExistenceNormalFloat;
end;
@ 

\begin{definition}
Let $x$ be a floating-point datum belonging to the format $\FF(beta,p,e_{\text{min}},e_{\text{max}})$.
We say $x$ is \define{Subnormal} if its magnitude lies between
$0<|x|<\beta^{e_{\text{min}}}$.
\end{definition}

\begin{def-remark}
The Standard says that ``floating-point numbers for a format with magnitude less than $b^{e_{\text{min}}}$ are called subnormal because their
magnitudes lie between zero and the smallest normal magnitude.''
In particular, this means that subnormal numbers must be finite.
We are being a bit more general than the Standard, allowing $\beta>0$
rather than $b\in\{2,10\}$.
\end{def-remark}

<<Definition: subnormal floating-point datum>>=
definition
  let beta, p, eMin, eMax;
  let IT be Float of beta, p, eMin, eMax;
  attr IT is subnormal means :Def9:
  ex x being Real st x = IT &
  ex iMin being negative Integer st iMin = eMin
  & 0 < |.x.| & |.x.| < beta to_power iMin;
end;
@ %def subnormal Def9

\begin{registration}
Every subnormal floating-point number is real.
\end{registration}

<<Register: every subnormal floating-point number is real>>=
registration
  let beta, p, eMin, eMax;
  cluster subnormal -> real for Float of beta, p, eMin, eMax;
  coherence;
end;
@

\begin{theorem}
Let $x$ be a real number. Then $x$ is a floating-point number if and
only if it belongs to a floating-point format.
\end{theorem}

<<Theorem: floating-point numbers are real floating-point format data>>=
theorem ThRealFloatsAreNumbers:
  for x being Real
  holds x in FLOAT_NUMBER(beta, p, eMin, eMax)
  iff x in FLOAT(beta, p, eMin, eMax)
proof
  let x be Real;
  thus x in FLOAT_NUMBER(beta, p, eMin, eMax)
  implies x in FLOAT(beta, p, eMin, eMax) by XBOOLE_0:def 3;
  thus x in FLOAT(beta, p, eMin, eMax)
  implies x in FLOAT_NUMBER(beta, p, eMin, eMax)
  proof
    assume A1: x in FLOAT(beta, p, eMin, eMax);
    not -0 in ExtREAL & not NaN in ExtREAL;
    then {-0, NaN} misses ExtREAL by ZFMISC_1:51;
    then A2: {-0, NaN} /\ REAL = {} by XBOOLE_1:63, NUMBERS:31, XBOOLE_0:def 7;
    x in REAL by XREAL_0:def 1;
    then not x in {-0, NaN} by A2,XBOOLE_0:def 4;
    hence x in FLOAT_NUMBER(beta, p, eMin, eMax) by A1,XBOOLE_0:def 3;
  end;
end;
@ %def ThRealFloatsAreNumbers

\begin{theorem}
Let $e_{\text{min}}\in\ZZ$ be a negative integer, $b$ be a valid radix
natural number. If $p=1$, then there is no subnormal floating-point
number in format $\FF(b, p, e_{\text{min}}, e_{\text{max}})$.
\end{theorem}

\begin{proof}[Proof sketch]
We see that the smallest positive floating-point number is $b^{e_{\text{min}}}$
but this is larger than the upper bound for subnormal numbers.
\end{proof}

<<Theorem: $e_{\text{min}}\in\ZZ$, $b\in\NN$, $p=1$ implies there is no subnormal floating-point numbers>>=
theorem
  p = 1 implies
  for b being valid_radix Nat
  for eMin being negative Integer
  holds not ex v being Float of b, p, eMin, eMax
  st v is subnormal
proof
  assume A1: p = 1;
  let b be valid_radix Nat;
  let eMin be negative Integer;
  reconsider x = b to_power (eMin - p + 1) as positive Real;
  A2: x = b to_power eMin by A1;
  for v being Float of b, p, eMin, eMax
  holds not v is subnormal
  proof
    let v be Float of b, p, eMin, eMax;
    assume v is subnormal;
    then consider x0 being Real such that
    A3: x0 = v & 0 < |.x0.| & |.x0.| < b to_power eMin;
    A4: |.x0.| < x by A2,A3;
    A5: x0 in FLOAT_NUMBER(b, p, eMin, eMax)
    & x0 is Float of b, p, eMin, eMax
    by A3, ThRealFloatsAreInFLOATNUMBER;
    0 < -x0 or 0 < x0 by A3, COMPLEX1:71;
    then per cases;
    suppose x0 is positive;
      then x0 is positive Float of b, p, eMin, eMax by A5, Def9a;
      then (b to_power (eMin - p + 1)) <= x0 by ThSmallestPositiveFloat;
      hence contradiction by A4, COMPLEX1:43;
    end;
    suppose A6: x0 is negative;
      then x0 is negative Float of b, p, eMin, eMax by A5, Def9b;
      then -(- x) <= -x0 by ThSmallestNegativeFloat, XREAL_1:24;
      hence contradiction by A4, A6, COMPLEX1:70;
    end;
  end;
  hence thesis;
end;
@ 

\begin{theorem}
There is no subnormal element of $\FF(\beta,p,-\infty,e_{\text{max}})$.
\end{theorem}

<<Theorem: there is no subnormal element of $\FF(\beta,p,-\infty,e_{\text{max}})$>>=
theorem
  eMin = -infty implies not ex v being Float of beta, p, eMin, eMax
  st v is subnormal;
@ 

\begin{theorem}
Zero is not a normal floating-point number, nor is it subnormal.
\end{theorem}

\begin{proof}[Proof sketch]
This boils down to proving that zero is not normal, and zero is not subnormal.
The proof that 0 is not normal is tedious but straightforward. The proof
that it is not subnormal is the same structure: assume 0 is subnormal,
then write down the definition, and observe this requires $0<|0|$ which is
impossible, since Theorem [[COMPLEX1:44]] proves $|0|=0$. 
\end{proof}

<<Theorem: 0 is neither normal nor subnormal>>=
theorem ThZeroIsNotNormal:
  for x being Float of beta, p, eMin, eMax
  st x = 0
  holds not x is normal & not x is subnormal
proof
  let x be Float of beta, p, eMin, eMax;
  assume A1: x = 0;
  thus not x is normal
  <<Proof: 0 is not normal>>
  thus not x is subnormal by A1, COMPLEX1:44;
end;
@ %def ThZeroIsNotNormal

\begin{proof}[Subproof (0 is not normal)]
This boils down to a proof by cases, then looking at the definition. In
every case, we see the definition explicitly requires $0<|x|$ or $0\neq x$.
\end{proof}

<<Proof: 0 is not normal>>=
proof
  assume A2: x is normal;
  per cases;
  suppose eMin = -infty;
    then x <> 0 by A2, Def8;
    hence contradiction by A1;
  end;
  suppose eMin <> -infty;
    then ex x0 being Real, iMin being negative Integer
    st iMin = eMin
    & x0 = x
    & beta to_power iMin <= |.x0.| by A2, Def8;
    then 0 < |.0.| by A1;
    hence contradiction by COMPLEX1:44;
  end;
end;
@

\begin{registration}
We now register the fact that zero floats are non-normal and non-subnormal,
normal floats are nonzero, and subnormal floats are nonzero.
\end{registration}

<<Register: zero, normal, subnormal floats are disjoint>>=
registration
  let beta, p, eMin, eMax;
  cluster zero -> non normal for Float of beta, p, eMin, eMax;
  coherence by ThZeroIsNotNormal;
  cluster zero -> non subnormal for Float of beta, p, eMin, eMax;
  coherence by ThZeroIsNotNormal;
  cluster normal -> non zero for Float of beta, p, eMin, eMax;
  coherence;
  cluster subnormal -> non zero for Float of beta, p, eMin, eMax;
  coherence;
end;
@ 


\begin{theorem}
Let $b\in\NN$ be a valid radix number, $e_{\text{min}}\in\ZZ$ be negative.
If $p>1$, then $b^{e_{\text{min}}+1-p}$ is subnormal.
\end{theorem}

<<Theorem: if $p>1$, then $b^{e_{\text{min}}+1-p}$ is subnormal>>=
theorem ThBabyExistenceSubnormalFloat:
  p > 1 implies
  for b being valid_radix Nat
  for eMin being negative Integer
  ex v being Float of b, p, eMin, eMax
  st v = (b to_power (1 - p))*(b to_power eMin)
  & v is subnormal
proof
  assume A1: p > 1;
  let b be valid_radix Nat;
  let eMin be negative Integer;
  ex v being Float of b, p, eMin, eMax
  st v = (b to_power (1 - p))*(b to_power eMin)
  proof
    set M = 1, e = eMin;
    set x = M * (b to_power (e - p + 1));
    reconsider x as positive Real;
    eMin + (- 1) < e + 0 by XREAL_1:8;
    then B1: x = M * (b to_power (e - p + 1))
    & 0 < M & M <= b to_power (p - 1)
    & eMin - 1 < e & e <= eMax by Lm19;
    then |.M.| <= b to_power (p - 1)
    & b to_power (p - 1) <= ((b to_power p) - 1) by Lm17, COMPLEX1:43;
    then |.M.| <= ((b to_power p) - 1) by XXREAL_0:2;
    then x in FLOAT_NUMBER(b,p,eMin,eMax) by B1, Th12a;
    then reconsider v=x as Float of b, p, eMin, eMax by ThRealFloatsAreInFLOATNUMBER;
    take v;
    x = b to_power ((1 - p) + e)
     .= (b to_power (1 - p)) * (b to_power e) by POWER:27;
    hence thesis;
  end;
  then consider v being Float of b, p, eMin, eMax such that
  A2: v = (b to_power (1 - p))*(b to_power eMin);
  take v;
  thus v = (b to_power (1 - p))*(b to_power eMin) by A2;
  ex x being Real st x = v & 0 < |.x.| & |.x.| < b to_power eMin
  proof
    reconsider x = (b to_power (1 - p))*(b to_power eMin) as Real;
    take x;
    thus x = v by A2;
    B1: b > 1 by Def1;
    B2: x = b to_power (1 - p + eMin) by POWER:27;
    thus 0 < |.x.|;
    1 + 1 <= p by A1, INT_1:7;
    then 1 - p <= 1 - 2 by XREAL_1:10;
    then 1 - p <= -1;
    then 1 - p + eMin < 0 + eMin by XREAL_1:8;
    then b to_power (1 - p + eMin) < b to_power eMin by B1, POWER:39;
    hence |.x.| < b to_power eMin by B2, COMPLEX1:43;
  end;
  hence v is subnormal;
end;
@ %def ThBabyExistenceSubnormalFloat

\begin{theorem}
Let $b\in\NN$ be a valid radix, $e_{\text{min}}\in\ZZ$ be negative, $p>1$.
Then there exists a
\end{theorem}

<<Theorem: Existence of subnormal float for $b\in\NN$, $e_{\text{min}}\in\ZZ$, and $p>1$>>=
theorem ThExistenceSubnormalFloat:
  p > 1 implies
  for b being valid_radix Nat
  for eMin being negative Integer
  ex v being Float of b, p, eMin, eMax
  st v is subnormal
proof
  assume A1: p > 1;
  let b be valid_radix Nat;
  let eMin be negative Integer;
  ex v being Float of b, p, eMin, eMax st
  v = (b to_power (1 - p))*(b to_power eMin)
  & v is subnormal
  by A1, ThBabyExistenceSubnormalFloat;
  hence thesis;
end;
@ %def ThExistenceSubnormalFloat

\begin{registration}
When $b$, $p$ are natural numbers greater than one, $e_{\text{min}}\in\ZZ$,
there exists subnormal floating-point numbers.
\end{registration}

<<Register: existence of subnormal floating-point numbers>>=
registration
  let b, p be valid_radix Nat;
  let eMin be negative Integer;
  let eMax;
  cluster subnormal for Float of b, p, eMin, eMax;
  existence by Def1, ThExistenceSubnormalFloat;
end;
@ 

\begin{definition*}
The Standard explicitly gives us five ``basic'' floating-point formats:
\begin{enumerate}
\item binary32 has $b=2$, $p=24$, $e_{\text{min}}=-126$, $e_{\text{max}}=127$
\item binary64 has $b=2$, $p=53$, $e_{\text{min}}=-1022$, $e_{\text{max}}=1023$
\item binary128 has $b=2$, $p=113$, $e_{\text{min}}=-16382$, $e_{\text{max}}=16383$
\item decimal64 has $b=10$, $p=16$, $e_{\text{min}}=-383$, $e_{\text{max}}=384$
\item decimal64 has $b=10$, $p=34$, $e_{\text{min}}=-6143$, $e_{\text{max}}=6144$
\end{enumerate}
\end{definition*}

<<Definition: basic floating-point formats>>=
definition
  mode Binary32Float is Float of 2, 24, -126, 127;
  mode Binary64Float is Float of 2, 53, -1022, 1023;
  mode Binary128Float is Float of 2, 113, -16382, 16383;
  mode Decimal64Float is Float of 10, 16, -383, 384;
  mode Decimal128Float is Float of 10, 34, -6143, 6144;
end;
@ %def Binary32Float Binary64Float Binary128Float Decimal64Float Decimal128Float

\begin{voc}
We register with Mizar these are all new modes.
\end{voc}

<<DICT/float-1.voc>>=
MBinary32Float
MBinary64Float
MBinary128Float
MDecimal64Float
MDecimal128Float
@

\begin{registration}
Observe that $b^{e_{\text{min}}-p+1}$ is a subnormal floating-point number.
\end{registration}

<<Register: subnormal for floating-point numbers>>=
registration
  let b, p, eMin, eMax;
  cluster subnormal for Element of FLOAT(b,p,eMin,eMax);
  existence
  proof
    set M = 1, e = eMin;
    set x = M * (b to_power (e - p + 1));
    x in FLOAT_NUMBER(b,p,eMin,eMax);
    then reconsider f=x as Element of FLOAT(b,p,eMin,eMax);
    take f;
    0 < |.x.| & |.x.| < b to_power eMin;
    hence thesis;
  end;
end;
@

\begin{definition}
Let $\beta$ be a valid radix real number, let $p$ be a natural number,
let $e_{\text{min}}\in\ZZ\cup\{-\infty\}$ and
$e_{\text{max}}\in\NN\cup\{+\infty\}$ be negative and positive integers
or infinities.
We define the set of \define{Floating-Point Representations} to be the
set $\FF_{r}(\b,p,e_{\text{min}},e_{\text{max}})$ equal to
$\{(s,e,m)\in\{0,1\}\times\ZZ\times\NN\mid (-1)^{s}m\times\beta^{e}\in\FF(\beta,p,e_{\text{min}},e_{\text{max}})\lor(s=1,e=m=0)\}\cup\{+\infty,-\infty,\qNaN,\sNaN\}$.
\end{definition}

This is a little too clever: signed zeros are now treated ``as if'' they
were a distinct real number (not equal to zero), but infinities as well
as \qNaN\ and \sNaN\ are treated as formal symbols. It is not until the
binary encoding do we treat $-\infty$ as $(1,e_{\text{max}},0)$ and
$+\infty$ as $(0,e_{\text{max}},0)$ (and similarly for the NaNs). We
should really be doing it \emph{here}, but the IEEE committee felt
differently. This is how the text read in the 2008 revision, as well.

However, one merit of this approach is that we could formalize a notion
of representations for ``idealized floating point'' which would take
$e_{\text{min}}=-\infty$ and $e_{\text{max}}=+\infty$. If we used
triples exclusively as the definition of a representation, then we'd
have to allow $e\in\ZZ\cup\{+\infty\}$ and insist $e=+\infty$ be
reserved for \NaN\ and $\pm\infty$. I'm not sure that's much better.

<<Definition: Floating-point representation>>=
definition
  let b, p, eMin, eMax;
  func FLOAT_REP(b, p, eMin, eMax) -> set equals
  {[s,e,m] where s is Element of {0,1}, e is Int, m is Nat :
  (s = 1 & e = 0 & m = 0)
  or (ex x being Element of FLOAT_NUMBER(b, p, eMin, eMax)
      st x = ((-1) |^ s) * m * (b to_power (e - p + 1)))} 
  \/ {-infty, +infty, qNaN, sNaN};
  coherence;
end;
@ %def FLOAT_REP

